[
    {
        "title": "HTTP协议",
        "author": "阿星Plus",
        "url": "2019-07-01-http",
        "markdown": "#### http和https\n\n* http协议：全称是 HyperText Transfer Protocol，意思是超文本传输协议，是一种发布和接收HTML页面的方法，服务器端口号是80。\n* https协议：是HTTP协议的加密版本，在HTTP下加入了SSL层，服务器端口号是443。\n\n**在浏览器中发送一个http请求的过程**\n\n* 当用户在浏览器地址栏钟输入一个URL访问之后，浏览器会向服务器发送HTTP请求，http请求主要分为 \"GET\" 和 \"POST\"。\n* 比如当我们在浏览器输入URL [http://baidu.com](http://baidu.com) 的时候，浏览器发一个Request请求去获取 [http://baidu.com](http://baidu.com) 的HTML文件，服务器把Response文件对象返回给浏览器。\n* 浏览器分析Response中的HTML，发现其中引用了很多其他文件，如图片、css、js等，浏览器会自动再次发送Request去获取这些文件。\n* 当所有文件都下载成功，网页会根据HTML语法结构，完整显示出来。\n\n#### URL组成\n\nURL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成：\n\n* schema：代表访问的协议，一般为http、https、ftp\n* host：主机名，域名，比如 www.baidu.com\n* post：端口号，当访问一个网站的时候，http默认使用80，https默认使用443\n* path：查找路径，比如 www.baidu.com/search/error.html , search/error.html就是path\n* query-string：查询字符串，比如 www.baidu.com/s?wd=python wd=python就是查询字符串\n* anchor：锚点，前端用来做页面定位用\n\n在浏览器中请求一个URL，浏览器会对这个url进行编码，除了英文字母、数字和不分符号外，其他全部使用百分号加十六进制值进行编码\n\n#### GET 和 POST\n\n在HTTP协议中定义了8种请求方法\n\n* GET：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会用GET请求\n* POST：向服务器发送数据、上传文件，会对服务器资源产生影响的时候会使用POST请求\n\n以上是网站开发中常用的两种方法，一般情况下都会遵循使用原则，但是有些网站和服务器为了做反爬虫机制，也经常不按常理出牌，要视情况而定。\n\n#### 请求头常见参数\n\n在HTTP协议中，向服务器发送一个请求，数据分为三个部分，第一个是把数据放在URL中，第二个是把数据放在body中\\(POST请求\\)，第三个就是把数据放在head中\n\n* User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到，请求一个网页的时候，服务器通过这个参数就可以知道当前请求是由哪种浏览器发送的，如果我们通过Python爬虫发送请求，那么User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易判断请求是爬虫。因为我们需要设置这个值为一些浏览器的值，来伪装爬虫。\n* Referer：表明当前这个请求是从哪个URL过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做响应的响应。\n* Cookie：HTTP协议是无状态的。同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人，因此需要用Cookie来做标识，一般如果想要做登录后才能访问的网站，那么就需要发送Cookie信息了。\n\n#### 常见响应状态码\n\n* 200 OK：客户端请求成功\n* 400 Bad Request：客户端请求有语法错误，不能被服务器所理解\n* 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n* 403 Forbidden：服务器收到请求，但是拒绝提供服务\n* 404 Not Found：请求资源不存在\n* 500 Internal Server Error：服务器发生不可预期的错误\n* 503 Server Unavailable：服务器当前不能出来客户端的请求，一段时间后可能恢复正常\n",
        "category": "Python",
        "tag": [
            "网络请求",
            "HTTP",
            "GET",
            "POST"
        ],
        "createdAt": "2019-07-01 19:13:40"
    },
    {
        "title": "urllib库",
        "author": "阿星Plus",
        "url": "2019-07-02-urllib",
        "markdown": "### urllib库\n\nurllib库是Python中一个最基本的网络请求库，可以模拟浏览器的行为，向指定服务器发送一个请求，并可以保存服务器返回的数据。\n\n#### urlopen函数\n\n在Python3的urllib库中，所有和网络相求相关的方法都被集成到 urlli.request 模块下了，urlopen函数基本使用方法\n\n```python\nfrom urllib import request\nresponse = request.urlopen('http://www.baidu.com')\nprint(response.read())\n```\n\n* url：请求的url\n* data：请求的data，如果设置了这个值，那么将变成POST请求\n* 返回值：返回值是一个 http.client.HTTPResponse 对象，这个对象是一个类文件句柄对象，有read\\(size\\)、readline、readlines、getcode 等方法\n\n实际上，使用浏览器访问百度，右键查看源代码，会发现和代码打印出来的数据是一模一样的。\n\n#### urlretrieve函数\n\n这个函数可以方便的将网页上的一个文件保存到本地\n\n```python\n// 以下代码可以将百度首页代码下载到本地\nfrom urllib import request\nrequest.urlretrieve('http://www.baidu.com', 'baidu.html')\n```\n\n#### urlencode函数\n\n用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动给我们进行编码。而如果使用代码发送请求，那么就必须手动进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据\n\n```python\nfrom urllib import parse\ndata = ['name':'阿星Plus','age':25,]\nqs = parse.urlencode(data)\nprint(qs)\n```\n\n#### parse\\_qs函数\n\n可以将经过编码后的url参数进行解码\n\n```python\nform urllib import parse\nqs = 'name=%E9%98%BF%E6%98%9FPlus&age=25'\nprint(parse.parse_qs(qs))\n```\n\n#### urlparse和urlsplit\n\n拿到一个URL，想要对这个URL中的各个组成部分进行分割，那么这时候就可以使用urlparse或者urlsplit来进行分割\n\n```python\nform urllib import request,parse\n\nurl = 'https://www.baidu.com/s?wd=阿星Plus'\n\n# result = parse.urlsplit(url)\nresult = parse.urlparse(url)\n\nprint('scheme:',result.scheme)\nprint('netloc:',result.netloc)\nprint('path:',result.path)\nprint('query:',result.query)\n```\n\nurlparse和urlsplit基本上是一模一样的，唯一不一样的是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。\n\n#### request.Request类\n\n如果想要在请求的时候增加一些请求头，那么就必须使用 request.Request 类来实现，比如要增加一个 User-Agent\n\n```python\nfrom urllib import request\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\nreq = request.Request('http://www.baidu.com', headers=headers)\nresp = request.urlopen(req)\nprint(resp.read()\n```\n\n#### ProxyHandler处理器\\(设置代理\\)\n\n* 很多网站会检测某一段时间某个IP的访问次数\\(通过流量统计，系统日志等\\)，如果访问次数多的不像正常人，它会禁止这个IP的访问\n* 所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取\n* urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理\n\n```python\nfrom urllib import request\n# 没有设置代理\nresp = request.urlopen('http://httpbin.org/get')\nprint(resp.read().decode(\"utf-8\"))\n\n# 设置代理\nhandler = request.ProxyHandler({\"http\":\"132.232.126.92\"})\nopener = request.build_opener(handler)\nreq = request.Request('http://httpbin.org/ip')\nresp = opener.open(req)\nprint(resp.read()\n```\n\n#### Cookie\n\n在网站中，HTTP请求是无状态的，也就是说即使第一次和服务器连接并登录成功后，第二次请求服务器依然不知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据\\(cookie\\)给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4kb，因此使用cookie只能存储一些小量的数据。\n\n**cookie的格式**\n\n```text\nSet-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE\n```\n\n* NAME：cookie的名字\n* VALUE：cookie的值\n* Expires：cookie的过期时间\n* Path：cookie的作用路径\n* Domain：cookie作用的域名\n* SECURE：是否只在https协议下起作用\n\n**使用cookielib库和HTTPCookieProcessor模拟登录**\n\n* Cookie是指网站服务器为了辨别用户身份和进行Session跟踪而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话\n* 这里以人人网为例，人人网中，要访问某个人的主页，必须先登录才能访问，登录就是需要有cookie信息。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中\n\n```python\nfrom urllib import request\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36',\n    'Cookie': 'anonymid=jy8dyj742asuaj; depovince=SH; _r01_=1; JSESSIONID=abc_7R4FWXud3fWjCgeWw; ick_login=501ccd78-b0b4-4253-b815-9992020c05de; jebecookies=c50e000a-723a-4f2f-ad13-6371cf5b4a63|||||; _de=2A184C89A453DAE2ECD78F48F9B08787; p=8de679b3735cc2d3245b06d272bc08665; first_login_flag=1; ln_uact=13477996338; ln_hurl=http://head.xiaonei.com/photos/0/0/men_main.gif; t=28a3a7049b82d64a7ef87911c789ac0a5; societyguester=28a3a7049b82d64a7ef87911c789ac0a5; id=971368245; xnsid=fbe5d896; ver=7.0; loginfrom=null; jebe_key=cb9f1dc6-cf33-4933-87e6-3289dc7cf36a%7C8ddf4c90ebf64a7cc8163133aa871bf1%7C1563436919308%7C1%7C1563436918703; jebe_key=cb9f1dc6-cf33-4933-87e6-3289dc7cf36a%7C8ddf4c90ebf64a7cc8163133aa871bf1%7C1563436919308%7C1%7C1563436918708; wp_fold=0'\n}\n\nurl = 'http://www.renren.com/971368245/profile'\nreq = request.Request(url, headers=headers)\nresp = request.urlopen(req)\nwith open('renren.html', 'w') as fp:\n    fp.write(resp.read().decode('utf-8'))\n```\n\n但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python中处理cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储cookie的对象，而HTTPCookieProcessor处理器主要作用是处理这些cookie对象，并构建handler对象。\n\n**http.cookiejar模块**\n\n该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar\n\n* CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失\n* FileCookieJar\\(filename,delayload=None,policy=None\\)：从CookieJar派生而来，用来创建FileCookieJar实例，检索Cookie信息并将Cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问文件，既只有在需要时才读取文件或在文件中存储数据\n* MozillaCookieJar\\(filename,delayload=None,policy=None\\)：从FileCookieJar派生而来，创建于Mozilla浏览器 cookies.txt兼容的FileCookieJar实例\n* LWPCookieJar\\(filename,delayload=None,policy=None\\)：从FileCookieJar派生而来,创建于libwww-pert标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例\n\n**使用http.cookiejar和request.HTTPCookieProcessor模拟登录**\n\n```python\nfrom urllib import request,parse\nfrom http.cookiejar import CookieJar\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ndef get_opener():\n    cookiejar = CookieJar()\n    handler = request.HTTPCookieProcessor(cookiejar)\n    opener = request.build_opener(handler)\n    return opener\n\ndef login_renren(opener):\n    data = {\"email\": \"\", \"password\": \"\"}\n    data = parse.urlencode(data).encode('utf-8')\n    login_url = \"http://www.renren.com/PLogin.do\"\n    req = request.Request(login_url, headers=headers, data=data)\n    opener.open(req)\n\ndef visit_profile(opener):\n    url = 'http://www.renren.com/971368245/profile'\n    req = request.Request(url,headers=headers)\n    resp = opener.open(req)\n    with open('renren.html','w') as fp:\n        fp.write(resp.read().decode(\"utf-8\"))\n\nif __name__ == '__main__':\n    opener = get_opener()\n    login_renren(opener)\n    visit_profile(opener)\n```\n\n**保存cookie到本地**\n\n保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名\n\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ncookiejar = MozillaCookieJar('cookie.txt')\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\n\nreq = request.Request('http://httpbin.org/cookies',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\ncookiejar.save(ignore_discard=True,ignore_expires=True)\n```\n\n**从本地加载cookie**\n\n从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法\n\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ncookiejar = MozillaCookieJar(\"cookie.txt\")\ncookiejar.load(ignore_expires=True,ignore_discard=True)\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\n\nreq = request.Request('http://httpbin.org/cookies',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\n```\n",
        "category": "Python",
        "tag": [
            "网络请求",
            "urllib",
            "ip代理",
            "cookie"
        ],
        "createdAt": "2019-07-02 20:20:11"
    },
    {
        "title": "requests库",
        "author": "阿星Plus",
        "url": "2019-07-03-requests",
        "markdown": "虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。\n\n### 安装和文档地址\n\n```text\npip install requests\n```\n\n* 中文文档：[http://docs.python-requests.org/zh\\_CN/latest/index.html](http://docs.python-requests.org/zh_CN/latest/index.html)\n* github地址：[https://github.com/requests/requests](https://github.com/requests/requests)\n\n### 发送GET请求\n\n* 最简单的发送get请求就是通过request.get来调用\n\n  ```python\n  response = request.get('http://www.baidu.com/')\n  ```\n\n* 添加header和查询参数，如果想要添加headers，可以传入headers参数来增加请求头中的headers信息，如果要将参数放在url中传递，可以利用params参数\n\n```python\nimport requests\nkw = {'wd': '中国'}\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\n# params 接受一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()\nresponse = request.get('http://www.baidu.com/s', params=kw, headers=headers)\n\n# 查看响应内容，response.text 返回的是Unicode格式的数据\nprint(response.text)\n\n# 查看响应内容，response.content 返回的是字节流数据\nprint(response.content)\n\n# 查看完整url地址\nprint(response.url)\n\n# 查看响应头部字符编码\nprint(response.encoding)\n\n# 查看响应码\nprint(response.status_code)\n```\n\n### 发送POST请求\n\n* 最基本的post请求可以使用post方法\n\n  ```python\n  response = request.post('http://www.baidu,com', data=data)\n  ```\n\n* 传入data数据，这时候就不需要urlencode进行编码了，直接传入一个字典进去就可以了\n\n  ```python\n  import requests\n  url = 'https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&needAddtionalResult=false&isSchoolJob=0'\n  headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36',\n    'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=&fromSearch=true&suginput='\n  }\n  data = {\n    'first': 'true',\n    'pn': 1,\n    'kd': 'python'\n  }\n  resp = requests.post(url, headers=headers, data=data)\n  # 如果是json数据，直接可以调用json方法\n  print(resp.json())\n  ```\n\n### 使用代理\n\n使用requests添加代理，只需要在请求的方法中传递proxies参数就可以了\n\n```python\nimport requests\nurl = 'http://httpbin.org/get'\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\nproxy = {\n    'http': '132.232.126.92'\n}\n\nresp = requests.get(url, headers=headers, proxies=proxy)\nwith open('http.html', 'w', encoding='utf-8') as fp:\n    fp.write(resp.text)\n```\n\n### cookie\n\n如果在一个响应中包含了cookie，那么可以利用cookie属性拿到这个返回的cookie值\n\n```python\nimport requests\n\nresp = requests.get('http://www.baidu.com/')\nprint(resp.cookies)\nprint(resp.cookies.get_dict())\n```\n\n### session\n\n* urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。\n* 使用requests，也要达到共享cookie的目的，可以用requests库提供的session对象。这里的session不是web开发中的session，这里只是一个会话的对象。\n\n```python\nimport requests\n\nurl = 'http://www.renren.com/PLogin.do'\ndata = {'email':'','password':''}\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\n# 登录\nsession = requests.session()\nsession.post(url, data=data, headers=headers)\n\n# 访问个人主页\nresp = session.get('http://www.renren.com/971368245/profile')\nprint(resp.text)\n```\n\n### 处理不受信任的SSL证书\n\n对于那些已经被信任的SSL整数的网站，比如 [https://www.baidu.com/](https://www.baidu.com/) ，那么使用requests直接就可以正常的返回响应，对于不受信任的网站，添加 verify=False 参数\n\n```python\nurl = 'https://xxx.com'\nresp = requests.get(url,verify=False)\nprint(resp.content.decode('utf-8'))\n```\n",
        "category": "Python",
        "tag": [
            "网络请求",
            "GET",
            "POST",
            "cookie",
            "requests",
            "session"
        ],
        "createdAt": "2019-07-03 21:15:22"
    },
    {
        "title": "XPath语法",
        "author": "阿星Plus",
        "url": "2019-07-04-xpath",
        "markdown": "## 什么是Xpath?\n\nXPath\\(XML Path Language\\) 是一门在XML和HTML文档中查找信息的语言，可以用来在XML和HTML文档中对元素和属性进行遍历\n\n## XPath工具\n\n* Chrome插件 [XPath Helper](https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl)\n* Firefox插件 [Try XPath](https://addons.mozilla.org/en-US/firefox/addon/try-xpath/)\n\n## XPath语法\n\n### 选取节点\n\nXPath使用路径表达式来选取XML文档中的节点或者节点集，这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似\n\n| 表达式 | 描述 | 示例 | 结果 |\n| :--- | :--- | :--- | :--- |\n| nodename | 选取此节点的所有子节点 | `bookstore` | 选取bookstore下所有的子节点 |\n| / | 如果是在最前面，代表从根节点选取，否则选择某节点下的某个节点 | `/bookstore` | 选取根元素下所有的bookstore节点 |\n| // | 从全局节点中选择节点，随意在哪个位置 | `//book` | 从全局节点中找到所有的book节点 |\n| @ | 选取某个节点的属性 | `//book[@price]` | 选择所有拥有price属性的book节点 |\n| . | 当前节点 | `./a` | 选取当前节点下的a标签 |\n\n### 谓语\n\n谓语用来查找某个特定的节点或者包含某个指定的值的及诶按，被嵌在括号中使用\n\n| 路径表达式 | 描述 |\n| :--- | :--- |\n| `//bookstore/book[1]` | 选取bookstore下的第一个book子元素 |\n| `//bookstore/book[last()]` | 选取bookstore下最后一个book子元素 |\n| `//bookstore/book[position()<3]` | 选取bookstore下前面两个book子元素 |\n| `//book[@price]` | 选取拥有price属性的book元素 |\n| `//book[@price=10]` | 选取拥有price属性并且等于10的book元素 |\n\n### 通配符\n\n在XPath中用 `*` 来表示通配符\n\n| 通配符 | 描述 | 示例 | 结果 |\n| :--- | :--- | :--- | :--- |\n| `*` | 匹配任意节点 | `/bookstore/*` | 选取bookstore下的所有子元素 |\n| `@*` | 匹配节点中的任意属性 | `//book[@*]` | 选取所有带属性的book元素 |\n\n### 选取多个路径\n\n通过在路径表达式中使用 `|` 运算符，可以选取若干个路径，比如选取所有book元素已经book元素下所有的title元素 `//bookstore/book | //book/title`\n",
        "category": "Python",
        "tag": [
            "数据提取",
            "xpath"
        ],
        "createdAt": "2019-07-04 22:33:33"
    },
    {
        "title": "lxml库",
        "author": "阿星Plus",
        "url": "2019-07-05-lxml",
        "markdown": "### lxml 介绍\n\n* lxml 是一个 HTML/XML 的解析器，主要的功能是如何解析和提取 HTML/XML 数据\n* lxml 和正则一样，用 C 语言实现的，是一款高性能的 Python HTML/XML 解析器，可以利用 XPath 语法，快速定位元素以及节点的信息\n* lxml Python 官方文档：[https://lxml.de/index.html](https://lxml.de/index.html)\n* 安装命令：`pip install lxml`\n\n### 基本使用\n\n可以利用 lxml 解析 HTML 代码，并且在解析 HTML 代码的时候，如果 HTML 代码不规范，缺少标签，lxml 会帮我们自动的进行补全\n\n```python\n# 使用lxml的etree库\nfrom lxml import etree\n\ntext = \"\"\"\n    <div>\n        <ul>\n            <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n            <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n            # 注意，此处缺少一个 </li> 闭合标签\n        </ul>\n    </div\n\"\"\"\n\n# 利用etree.HTML，将字符串解析为HTML文档\nhtml = etree.HTML(text)\n\n# 按字符串序列化HTML文档\nresult = etree.tostring(html)\n\nprint(result)\n```\n\n输出结果如下，可以看到 lxml 会自动修改 HTML 代码，不仅补全了 li 标签，还添加了 body,html 标签\n\n```markup\n<html>\n  <body>\n    <div>\n      <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n      </ul>\n    </div>\n  </body>\n</html>\n```\n\n### 从文件中读取 HTML 代码\n\n除了直接使用字符串进行解析，lxml 还支持冲文件中读取内容，新建一个 hello.html 文件，内容如下，然后利用 `etree.parse()` 方法来读取文件\n\n```markup\n<div>\n  <ul>\n    <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n    <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n    <li class=\"item-inactive\">\n      <a href=\"link3.html\"><span class=\"bold\">third item</span></a>\n    </li>\n    <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n    <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n  </ul>\n</div>\n```\n\n```python\nfrom lxml import etree\n\n# 读取HTML文件\nhtml = etree.parse('hello.html')\nresult = etree.tostring(html, pretty_print=True)\n\n# 输出结果和之前相同\nprint(result)\n```\n\n### 在lxml中使用XPath语法\n\n* 获取所有li标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\nprint(type(html)) # 显示 etree.parse() 返回类型\n\nresult = html.xpath('//li')\n\nprint(result) # 打印 <li> 标签的元素集合\n```\n\n* 获取所有li元素下的所有class属性的值\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/@class')\n\nprint(result)\n```\n\n* 获取所有li标签下href为link1.html的a标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/a[@href=\"link1.html\"]')\n\nprint(result)\n```\n\n* 获取li标签下所有span标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li//span')\n# //li/span 是不对的，因为 / 是用来获取子元素的，span 并不是 li 的子元素，所有要用双斜杠\n\nprint(result)\n```\n\n* 获取li标签下的a标签里的所有class\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/a//@class')\n\nprint(result)\n```\n\n* 获取最后一个li的a的href属性对应的值\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li[last()]/a/@href')\n\nprint(result)\n```\n\n* 获取倒数第二个li元素的内容\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li[last()-1]/a')\n# result = html.xpath('//li[last()-1]/a/text()')\n\nprint(result)\n```\n\n#### 案例：使用requests和xpath爬取电影天堂\n\n```python\nfrom lxml import etree\nimport requests\n\nBASE_DOMAIN = 'https://www.dytt8.net'\n\nHEADERS = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n}\n\ndef get_detail_urls(url):\n    response = requests.get(url, headers=HEADERS)\n\n    text = response.text\n    html = etree.HTML(text)\n\n    detail_urls = html.xpath(\"//table[@class='tbspan']//a/@href\")\n    detail_urls = map(lambda url: BASE_DOMAIN + url, detail_urls)\n\n    return detail_urls\n\ndef parse_detail_page(url):\n    movie = {}\n\n    response = requests.get(url, headers=HEADERS)\n    text = response.content.decode('gbk')\n\n    html = etree.HTML(text)\n\n    def parse_info(info, rule):\n        return info.replace(rule, \"\").strip()\n\n    title = html.xpath(\"//div[@class='title_all']//font[@color='#07519a']/text()\")[0]\n    movie['title'] = title\n\n    zoomE = html.xpath(\"//div[@id='Zoom']\")[0]\n    imgs = zoomE.xpath(\".//img/@src\")\n    cover = imgs[0]\n    screenshot = imgs[1]\n    movie['cover'] = cover\n    movie['screenshot'] = screenshot\n\n    infos = zoomE.xpath(\".//text()\")\n    for index, info in enumerate(infos):\n        if info.startswith('◎年　　代'):\n            info = parse_info(info, '◎年　　代')\n            movie[\"year\"] = info\n        elif info.startswith('◎产　　地'):\n            info = parse_info(info, '◎产　　地')\n            movie[\"country\"] = info\n        elif info.startswith('◎类　　别'):\n            info = parse_info(info, '◎类　　别')\n            movie[\"category\"] = info\n        elif info.startswith('◎豆瓣评分'):\n            info = parse_info(info, '◎豆瓣评分')\n            movie[\"rating\"] = info\n        elif info.startswith('◎片　　长'):\n            info = parse_info(info, '◎片　　长')\n            movie[\"duration\"] = info\n        elif info.startswith('◎导　　演'):\n            info = parse_info(info, '◎导　　演')\n            movie[\"director\"] = info\n        elif info.startswith('◎主　　演'):\n            info = parse_info(info, '◎主　　演')\n            actors = [info]\n            for x in range(index+1, len(infos)):\n                actor = infos[x].strip()\n                if actor.startswith('◎'):\n                    break\n                actors.append(actor)\n            movie[\"actors\"] = actors\n        elif info.startswith('◎简　　介 '):\n            info = parse_info(info, '◎简　　介')\n            for x in range(index+1, len(infos)):\n                profile = infos[x].strip()\n                movie[\"profile\"] = profile\n\n    download_url = html.xpath(\"//td[@bgcolor='#fdfddf']/a/@href\")[0]\n    movie[\"download_url\"] = download_url\n    return movie\n\ndef spider():\n    base_url = 'https://www.dytt8.net/html/gndy/dyzz/list_23_{}.html'\n    for x in range(1, 3):\n        url = base_url.format(x)\n        detail_urls = get_detail_urls(url)\n        for detial_url in detail_urls:\n            movie = parse_detail_page(detial_url)\n            print(movie)\n\nif __name__ == \"__main__\":\n    spider()\n```\n",
        "category": "Python",
        "tag": [
            "requests",
            "数据提取",
            "lxml",
            "etree"
        ],
        "createdAt": "2019-07-05 23:18:44"
    },
    {
        "title": "BeautifulSoup库",
        "author": "阿星Plus",
        "url": "2019-07-06-beautifulsoup",
        "markdown": "### BeautifulSoup\n\n- 和 lxml 一样，Beautiful Soup 也是一个 HTML/XML 的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。\n- lxml 只会局部遍历，而 Beautiful Soup 是基于 HTML DOM（Document Object Model）的，会载入整个文档，解析整个 DOM 树，因此时间和内存开销都会大很多，所以- 性能要低于 lxml。\n- BeautifulSoup 用来解析 HTML 比较简单，API 非常人性化，支持 CSS 选择器、Python 标准库中的 HTML 解析器，也支持 lxml 的 XML 解析器。\n- Beautiful Soup 3 目前已经停止开发，推荐现在的项目使用 Beautiful Soup 4。\n- 安装命令：pip install pip install bs4\n- 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n\n### Python 中的解析工具\n\n| 解析工具      | 解析速度 | 使用难度 |\n| :------------ | :------- | :------- |\n| BeautifulSoup | 最慢     | 最简单   |\n| lxml          | 快       | 简单     |\n| 正则表达式    | 最快     | 最难     |\n\n### 简单使用\n\n```python\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n\"\"\"\n\n# 创建 BeautifulSoup 对象，使用lxml解析\nsoup = BeautifulSoup(html,'lxml')\n\nprint(soup.prettify())\n```\n\n### 四个常用的对象\n\nBeautifulSoup将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：Tag、NavigatableString、BeautifulSoup、Comment\n\n#### Tag\n\nTag其实就是HTML中的标签\n\n```python\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n\"\"\"\n\n# 创建 BeautifulSoup 对象\nsoup = BeautifulSoup(html, 'lxml')\n\nprint(soup.title)\n# <title>The Dormouse's story</title>\n\nprint(soup.head)\n# <head><title>The Dormouse's story</title></head>\n\nprint(soup.a)\n# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n\nprint(soup.p)\n# <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\nprint(type(soup.p))\n# <class 'bs4.element.Tag'>\n```\n\n可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是 bs4.element.Tag，查找的是所有内容中的第一个符合要求的标签。对于Tag，他有两个重要的属性，分别是 name 和 attrs\n\n```python\nprint(soup.name)\n# [document]\n#soup 对象本身比较特殊，它的 name 即为 [document]\n\nprint(soup.head.name)\n# head\n#对于其他内部标签，输出的值便为标签本身的名称\n\nprint(soup.p.attrs)\n# {'class': ['title'], 'name': 'dromouse'}\n# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。\n\nprint(soup.p['class'])\nprint(soup.p.get('class'))\n# ['title']\n#还可以利用get方法，传入属性的名称，二者是等价的\n\n# 可以对这些属性和内容等等进行修改\nsoup.p['class'] = \"newClass\"\nprint(soup.p ) # <p class=\"newClass\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n```\n\n#### NavigableString\n\n如果拿到标签后，还想获取标签中的的内容，那么可以通过 tag.string 获取标签中的文本内容\n\n```python\nprint(soup.p.string)\n# The Dormouse's story\n\nprint(type(soup.p.string))\n# <class 'bs4.element.NavigableString'>\n```\n\n#### BeautifulSoup\n\nBeautifulSoup 对象表示的是一个文档的全部内容，大部分时候可以把它当做Tag对象，它支持 遍历文档数 和 搜索文档数 中描述的大部分方法。\n\n因为BeautifulSoup 对象并不是真正的HTML或XML的Tag，所以他没有name和attribute属性，但查看它的 ```.name``` 属性是很方便的，BeautifulSoup 对象包含了一个值为 ```[document]``` 的特殊属性 ```.name```\n\n```python\nprint(soup.name)\n# '[document]'\n```\n\n#### Comment\n\nTag , NavigableString , BeautifulSoup 几乎覆盖了HTML和XML中的所有内容，但是还有一些特殊对象，注释。\n\n```python\nmarkup = \"<b><!--Hey, buddy. Want to buy a used parser?--></b>\"\nsoup = BeautifulSoup(markup)\ncomment = soup.b.string\ntype(comment)\n# <class 'bs4.element.Comment'>\n```\n\nComment 对象是一个特殊类型的 NavigableString 对象\n\n```python\ncomment\n# 'Hey, buddy. Want to buy a used parser'\n```\n\n### 遍历文档树\n\n#### contents和children\n\n```python\nfrom bs4 import BeautifulSoup\nhtml_doc = \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\nsoup = BeautifulSoup(html_doc, 'lxml')\n\nhead_tag = soup.head\n\n# <head><title>The Dormouse's story</title></head>\nprint(head_tag)\n\n# 返回所有子节点的迭代器\nfor child in head_tag.children:\n    print(child)\n```\n\n#### strings和stripped_strings\n\n如果tag中包含多个字符串，可以使用 strings 来循环获取\n\n```python\nfor string in soup.strings:\n    print(repr(string))\n    # \"The Dormouse's story\"\n    # '\\n'\n    # \"The Dormouse's story\"\n    # '\\n'\n    # 'Once upon a time there were three little sisters; and their names were\\n'\n    # 'Elsie'\n    # ',\\n'\n    # 'Lacie'\n    # ' and\\n'\n    # 'Tillie'\n    # ';\\nand they lived at the bottom of a well.'\n    # '\\n'\n    # '...'\n    # '\\n'\n```\n\n输出的字符串中可能包含了很多空格和空白字符，使用 ```stripped_strings``` 可以去除多余空白内容\n\n```python\nfor string in soup.stripped_strings:\n    print(repr(string))\n    # \"The Dormouse's story\"\n    # \"The Dormouse's story\"\n    # 'Once upon a time there were three little sisters; and their names were'\n    # 'Elsie'\n    # ','\n    # 'Lacie'\n    # 'and'\n    # 'Tillie'\n    # ';\\nand they lived at the bottom of a well.'\n    # '...'\n```\n\n### 搜索文档树\n\n#### find和find_all\n\n- 搜索文档树，用的比较多的是 ```find``` 和 ```find_all```\n- ```find``` 方法是找到第一个满足条件的标签后就立即返回，只返回一个元素\n- ```find_all``` 方法是把所有满足条件的标签都返回\n\n```python\nsoup.find_all('a', attrs={'id': 'link2'})\n```\n\n或者是直接传入属性的名字作为关键字参数\n\n```python\nsoup.find_all('a', id='link2')\n```\n\n#### select\n\n使用以上方法可以方便的找出元素，但有时候使用css选择器的方式可以更加的方便，应该使用select方法。\n\n##### 通过标签名查找\n\n```python\nprint(soup.select('a'))\n```\n\n##### 通过类名查找\n\n通过类名，应该在类的前面加一个 ```.``` ，比如要查找 class='sister' 的标签\n\n```python\nprint(soup.select('.sister'))\n```\n\n##### 通过id查找\n\n通过id查找，应该在id的名字前面加一个 ```#```\n\n```python\nprint(soup.select('#link1'))\n```\n\n##### 组合查找\n\n组合查找即和写class文件时，标签名与类名、id名进行组合原理是一样的，例如查找p标签中，id='link1'的内容\n\n```python\nprint(soup.select('p #link1'))\n\n```\n\n直接子标签查找，则使用 ```>``` 分割\n\n```python\nprint(soup.select('head > title'))\n```\n\n##### 通过属性查找\n\n查找时还可以加入属性元素，属性需要用中括号括起来，属性和标签属于同一个节点，所以中间不能加空格，否则会无法匹配到\n\n```python\nprint(soup.select('a[href=\"http://example.com/elsie\"]'))\n```\n\n##### 获取内容\n\n以上的select方法返回的结果都是列表形式，可以用遍历的形式输出，然后用 ```get_text()``` 方法来获取它的内容\n\n```python\nsoup = BeautifulSoup(html, 'lxml')\nprint(type(soup.select('title')))\nprint(soup.select('title')[0].get_text())\n\nfor title in soup.select('title'):\n    print(title.get_text())\n```\n",
        "category": "Python",
        "tag": [
            "数据提取",
            "BeautifulSoup"
        ],
        "createdAt": "2019-07-06 19:20:55"
    },
    {
        "title": "Python中的正则表达式",
        "author": "阿星Plus",
        "url": "2019-07-07-regex",
        "markdown": "### 什么是正则表达式\n\n> 世界上分为两种人，一种是懂正则表达式的，一种是不懂正则表达式的\n\n按照一定的规则，从某个字符串中匹配出想要的数据，这个规则就是正则表达式\n\n### 正则表达式常用的匹配规则\n\n#### 匹配某个字符串\n\n```python\ntext = 'hello'\nret = re.match('he', text)\nprint(ret.group())\n# >> he\n```\n\n#### 点(```.```) 匹配任意的字符串\n\n```python\ntext = 'ab'\nret = re.match('.', text)\nprint(ret.group())\n# >> a\n```\n\n#### ```\\d``` 匹配任意的数字\n\n```python\ntext = '123'\nret = re.match('\\d', text)\nprint(ret.group())\n# >> 1\n```\n\n#### ```\\D``` 匹配任意的非数字\n\n```python\ntext = \"a\"\nret = re.match('\\D',text)\nprint(ret.group())\n# >> a\n```\n\n如果text为一个数字，那么就匹配不成功了\n\n```python\ntext = \"1\"\nret = re.match('\\D',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n#### ```\\s``` 匹配的是空白字符串(包括：\\n，\\t，\\r，空格)\n\n```python\ntext = \"\\t\"\nret = re.match('\\s',text)\nprint(ret.group())\n# >> 此处是一个空白\n```\n\n#### ```\\w``` 匹配的是 a-z 和 A-Z 以及数字和下划线\n\n```python\ntext = \"_\"\nret = re.match('\\w',text)\nprint(ret.group())\n# >> _\n```\n\n如果要匹配一个其他的字符，那么就匹配不到\n\n```python\ntext = \"+\"\nret = re.match('\\w',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n#### ```\\W``` 匹配的是和 ```\\w``` 相反的\n\n```python\ntext = \"+\"\nret = re.match('\\W',text)\nprint(ret.group())\n# >> +\n```\n\n如果你的text是一个下划线或者英文字符，那么就匹配不到了\n\n```python\ntext = \"_\"\nret = re.match('\\W',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n#### ```[]``` 组合的方式，只要满足中括号中的某一项都算匹配成功\n\n```python\ntext = \"027-88888888\"\nret = re.match('[\\d\\-]+',text)\nprint(ret.group())\n# >> 027-88888888\n```\n\n其实可以使用中括号代替几种默认的匹配规则\n\n- ```\\d``` ：[0-9]\n- ```\\D``` ：0-9\n- ```\\w``` ：[0-9a-zA-Z_]\n- ```\\W``` ：[^0-9a-zA-Z_]\n\n#### 匹配多个字符\n\n##### ```*```：可以匹配0或者任意多个字符\n\n```python\ntext = '8888'\nret = re.match('\\d*',text)\nprint(ret.group())\n# >> 8888\n```\n\n以上因为匹配的要求是 ```\\d``` ，那么就要求是数字，后面跟了一个星号，就可以匹配到8888这四个字符\n\n##### ```+```：可以匹配1个或者多个字符，最少一个\n\n```python\ntext = \"abc\"\nret = re.match('\\w+',text)\nprint(ret.group())\n# >> abc\n```\n\n因为匹配的是```\\w``` ，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足 ```\\w``` 的字符才能够匹配到。如果text是一个空白字符或者是一个不满足```\\w```的字符，就会报错\n\n```python\ntext = \"\"\nret = re.match('\\w+',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n##### ```?```：匹配的字符可以出现一次或者不出现(0或者1)\n\n```python\ntext = \"123\"\nret = re.match('\\d?',text)\nprint(ret.group())\n# >> 1\n```\n\n##### ```{m}```：匹配m个字符\n\n```python\ntext = \"123\"\nret = re.match('\\d{2}',text)\nprint(ret.group())\n# >> 12\n```\n\n##### ```{m,n}```：匹配 m-n 个字符，在这中间的字符都可以匹配到\n\n```python\ntext = \"123\"\nret = re.match('\\d{1,2}',text)\nprit(ret.group())\n# >> 12\n```\n\n如果text只有一个字符，也可以匹配出来\n\n```python\ntext = \"1\"\nret = re.match('\\d{1,2}',text)\nprit(ret.group())\n# >> 1\n```\n\n\n#### 几个实际的案例(以给出的文本为例)\n\n- 验证手机号码：手机号码的规则是以1开头，第二位可以是34587，后面那9位就可以随意了\n\n```python\ntext = \"18570631587\"\nret = re.match('1[34587]\\d{9}',text)\nprint(ret.group())\n# >> 18570631587\n```\n\n- 如果是个不满足条件的手机号码。那么就匹配不到了\n\n```python\ntext = \"1857063158\"\nret = re.match('1[34587]\\d{9}',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n- 验证邮箱：邮箱的规则是邮箱名称是用数字、数字、下划线组成的，然后是@符号，后面就是域名了\n\n```python\ntext = \"hynever@163.com\"\nret = re.match('\\w+@\\w+\\.[a-zA-Z\\.]+',text)\nprint(ret.group())\n```\n\n- 验证URL：URL的规则是前面是http或者https或者是ftp然后再加上一个冒号，再加上一个斜杠，再后面就是可以出现任意非空白字符了\n\n```python\ntext = \"http://www.baidu.com/\"\nret = re.match('(http|https|ftp)://[^\\s]+',text)\nprint(ret.group())\n```\n\n- 验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X\n\n```python\ntext = \"3113111890812323X\"\nret = re.match('\\d{17}[\\dxX]',text)\nprint(ret.group())\n```\n\n#### ```^```：表示以...开始\n\n```python\ntext = \"hello\"\nret = re.match('^h',text)\nprint(ret.group())\n```\n\n如果是在中括号中，代表的是取反操作\n\n#### ```$```：表示以...结束\n\n```python\n# 匹配163.com的邮箱\ntext = \"xxx@163.com\"\nret = re.search('\\w+@163\\.com$',text)\nprint(ret.group())\n# >> xxx@163.com\n```\n\n#### ```|```：匹配多个表达式或者字符串\n\n```python\ntext = \"hello|world\"\nret = re.search('hello',text)\nprint(ret.group())\n# >> hello\n```\n\n#### 贪婪模式和非贪婪模式\n\n- 贪婪模式：正则表达式会匹配尽量多的字符，默认是贪婪模式。\n- 非贪婪模式：正则表达式会尽量少的匹配字符。\n\n```python\ntext = \"0123456\"\nret = re.match('\\d+',text)\nprint(ret.group())\n# 因为默认采用贪婪模式，所以会输出0123456\n```\n\n可以改成非贪婪模式，就只会匹配到0\n\n```python\ntext = \"0123456\"\nret = re.match('\\d+?',text)\nprint(ret.group())\n```\n\n#### 匹配0-100之间的数字\n\n```python\ntext = '99'\nret = re.match('[1-9]?\\d$|100$',text)\nprint(ret.group())\n```\n\n如果text=101，就会抛出一个异常\n\n```python\ntext = '101'\nret = re.match('[1-9]?\\d$|100$',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n#### 转义字符和原生字符\n\n在正则表达式中，有些字符是有特殊意义的字符，在 Python 中 ```\\``` 也是用来转义的，因此如果想要在普通的字符串中匹配 ```\\``` ，那么就要给出 四个 ```\\```\n\n```python\ntext = \"apple \\c\"\nret = re.search('\\\\\\\\c',text)\nprint(ret.group())\n```\n\n所以要使用原生字符就可以解决这个问题\n\n```python\ntext = \"apple \\c\"\nret = re.search(r'\\\\c',text)\nprint(ret.group())\n```\n",
        "category": "Python",
        "tag": [
            "数据提取",
            "Regex"
        ],
        "createdAt": "2019-07-07 20:21:12"
    },
    {
        "title": "re模块",
        "author": "阿星Plus",
        "url": "2019-07-08-python-re",
        "markdown": "### match\n\n从开始的位置进行匹配，如果开始的位置没有匹配到，就直接匹配失败\n\n```python\ntext = 'hello'\nret = re.match('h', text)\nprint(ret.group())\n# >> h\n```\n\n如果第一个字母不是h，那么就会失败\n\n```python\ntext = 'ahello'\nret = re.match('h',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n如果想要匹配换行的数据，那么就要传入一个 ```flag=re.DOTALL``` ，就可以匹配换行符了\n\n```python\ntext = \"abc\\nabc\"\nret = re.match('abc.*abc',text,re.DOTALL)\nprint(ret.group())\n```\n\n### search\n\n在字符串中找满足条件的字符，如果找到，就返回，就是只会找到第一个满足条件的\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.search('\\d+',text)\nprint(ret.group())\n# >> 99\n```\n\n### group\n\n在正则表达式中，可以对过滤到的字符串进行分组，分组要使用圆括号的方式\n\n- group：和 group(0) 是等价的，返回的是整个满足条件的字符串\n- groups：返回的是里面的子组，索引从1开始\n- group(1)：返回的是第一个子组，可以传入多个\n\n```python\ntext = \"apple price is $99,orange price is $10\"\nret = re.search(r\".*(\\$\\d+).*(\\$\\d+)\",text)\nprint(ret.group())\nprint(ret.group(0))\nprint(ret.group(1))\nprint(ret.group(2))\nprint(ret.groups())\n```\n\n### findall\n\n找到所有满足条件的，返回的是一个列表\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.findall('\\d+',text)\nprint(ret)\n# >> ['99', '88']\n```\n\n### sub\n\n用来替换字符串，将匹配到的字符串替换为其他字符串\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.sub('\\d+','0',text)\nprint(ret)\n# >> apple price $0 orange price $0\n```\n\n### split\n\n使用正则表达式来分割字符串\n\n```python\ntext = \"hello world ni hao\"\nret = re.split('\\W',text)\nprint(ret)\n# >> [\"hello\",\"world\",\"ni\",\"hao\"]\n```\n\n### compile\n\n对于一些经常要用到的正则表达式，可以使用 compile 进行编译，后期再使用的时候可以直接拿来使用，执行效率会更快。而且compile还可以指定 ```flag=re.VERBOSE``` ，在写正则表达式的时候可以做好注释\n\n```python\ntext = \"the number is 20.50\"\nr = re.compile(r\"\"\"\n                \\d+ # 小数点前面的数字\n                \\.? # 小数点\n                \\d* # 小数点后面的数字\n                \"\"\",re.VERBOSE)\nret = re.search(r,text)\nprint(ret.group())\n```\n",
        "category": "Python",
        "tag": [
            "数据提取",
            "Regex"
        ],
        "createdAt": "2019-07-08 21:33:33"
    },
    {
        "title": "json文件处理",
        "author": "阿星Plus",
        "url": "2019-07-09-json",
        "markdown": "### 什么是json\n\nJSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n### json支持的数据格式\n\n- 对象(字典)，使用花括号\n- 数组(列表)，使用方括号\n- 整型、浮点型、布尔型、NULL类型\n- 字符串类型(字符串必须要用双引号，不能用单引号)\n- 多个数据之间使用逗号分开\n- json本质上还是一个字符串\n\n### 字典和列表转json\n\n```python\nimport json\n\nbooks = {\n    {\n        'title': '钢铁是怎样练成的',\n        'price': 9.8\n    },\n    {\n        'title': '红楼梦',\n        'price': 9.9\n    }\n}\n\njson_str = json.dumps(books, ensure_ascii=False)\nprint(json_str)\n```\n\n- 因为json在dump的时候，只能存放ascii的字符，因为会将中文进行转义，这时候我们可以使用 ```ensure_ascii=False``` 关闭这个特性。\n- 在python中，只有基本数据类型才能转换成json格式的字符串，int、float、str、list、dict、tuple\n\n### 将json数据直接dump到文件中\n\njson模块中除了dumps函数，还有一个dump函数，这个函数可以传入一个文件指针，直接将字符串dump到文件中\n\n```python\nimport json\n\nbooks = {\n    {\n        'title': '钢铁是怎样练成的',\n        'price': 9.8\n    },\n    {\n        'title': '红楼梦',\n        'price': 9.9\n    }\n}\n\nwith open('books.json', 'w') as fp:\n    json.dump(books, fp)\n```\n\n### 将一个json字符串load成python对象\n\n```python\nimport json\n\njson_str = '[{\"title\": \"钢铁是怎样练成的\", \"price\": 9.8}, {\"title\": \"红楼梦\", \"price\": 9.9}]'\n\nbooks = json.loads(json_str, encoding='utf-8')\nprint(type(books)) # <class 'list'>\nprint(books)\n```\n\n### 直接从文件中读取json数据\n\n```python\nimport json\n\nwith open('books.json','r',encoding='utf-8') as fp:\n    json_str = json.load(fp)\n    print(json_str)\n```\n",
        "category": "Python",
        "tag": [
            "数据存储",
            "json"
        ],
        "createdAt": "2019-07-09 22:44:50"
    },
    {
        "title": "csv文件处理",
        "author": "阿星Plus",
        "url": "2019-07-10-csv",
        "markdown": "### 读取csv文件\n\n```python\nimport csv\n\nwith open('demo.csv', 'r') as fp:\n    reader = csv.reader(fp)\n    titles = next(reader)\n    for x in reader:\n        print(x)\n```\n\n这样操作以后获取数据的时候，就要通过下标来获取数据。如果想要在获取数据的时候通过标题来获取，那么就可以使用 DictReader\n\n```python\nimport csv\n\nwith open('demo.csv', 'r') as fp:\n    reader = csv.DictReader(fp)\n    for x in reader:\n        print(x['title'])\n```\n\n### 写入数据到csv文件\n\n写入数据到csv文件，需要创建一个write对象，主要用到两个方法，一个是writerow写入一行，一个是writerows写入多行\n\n```python\nimport csv\n\nheaders = ['name','age','classroom']\nvalues = [\n    ('aaa',18,'111'),\n    ('bbb',19,'222'),\n    ('ccc',20,'333')\n]\n\nwith open('class.csv', 'w', newline='') as fp:\n    writer = csv.writer(fp)\n    writer.writerow(headers)\n    writer.writerows(values)\n```\n\n也可以使用字典的方式把数据写入进去，这是需要使用DictWriter\n\n```python\nimport csv\n\nheaders = ['name','age','classroom']\nvalues = [\n    {'name':'aaa','age':18,'classroom':'111'},\n    {'name':'bbb','age':19,'classroom':'222'}\n]\n\nwith open('class.csv', 'w', newline='') as fp:\n    writer = csv.DictWriter(fp,headers)\n    writer = csv.writeheader()\n    writer.writerow({'name':'ccc','age':20,'classroom':'333'})\n    writer.writerows(values)\n```\n",
        "category": "Python",
        "tag": [
            "数据存储",
            "csv"
        ],
        "createdAt": "2019-07-10 23:10:44"
    },
    {
        "title": "Python操作MySQL数据库",
        "author": "阿星Plus",
        "url": "2019-07-11-pymysql",
        "markdown": "### Windows下安装MySQL\n\n详细可参考 [Windows下MySQL安装流程，8.0以上版本ROOT密码报错及修改](/mysql/mysql-install.md)\n\n### 安装驱动程序\n\npython想要操作MySQL，必须要有一个中间件，或者叫做驱动程序，驱动程序有很多，mysqlclient、mysqldb、pymysql。我选择用pymysql，安装命令：```pip install pymysql```\n\n### 连接数据库\n\n```python\nimport pymysql\n\ndb = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\ncursor = db.cursor()\ncursor.execute('select 1')\n\ndata = cursor.fetchone()\nprint(data)\n\ndb.close()\n```\n\n### 插入数据\n\n```python\nimport pymysql\n\ndb = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\ncursor = db.cursor()\n\nsql = \"\"\"\n    insert into user(id,username,gender,age,password) values(null,'abc',1,18,'111111');\n\"\"\"\n\ncursor.execute(sql)\ndb.commit()\ndb.close()\n```\n\n将数据作为参数的方式插入到数据库\n\n```python\nsql = \"\"\"\n    insert into user(id,username,gender,age,password) values(null,%s,%s,%s,%s);\n\"\"\"\n\ncursor.execute(sql,('spider',1,20,'222222'))\n```\n\n### 查找数据\n\n使用pymysql查询数据，可以使用 fetch 方法\n\n- fetchone()：这个方法每次只获取一条数据\n- fetchall()：这个方法接收全部的返回结果\n- fetchmany(size)：这个方法可以获取指定条数的数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nwhile True:\n    result = cursor.fetchone()\n    if not result:\n        break\n    print(result)\n\ndb.close()\n```\n\n直接使用fetchall，一次性可以把所有满足条件的数据都取出来\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nresults = cursor.fetchall()\nfor result in results:\n    print(result)\n\ndb.close()\n```\n\n使用fetchmany，指定获取多少条数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nresults = cursor.fetchmany(1)\nfor result in results:\n    print(result)\n\ndb.close()\n```\n\n### 删除数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    delete from user where id=1\n\"\"\"\n\ncursor.execute(sql)\ndb.commit()\n\ndb.close()\n```\n\n### 更新数据\n\n```python\nconn = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\nsql = \"\"\"\n    update user set username='aaa' where id=1\n\"\"\"\ncursor.execute(sql)\nconn.commit()\n\nconn.close()\n```\n",
        "category": "Python",
        "tag": [
            "数据存储",
            "MySQL"
        ],
        "createdAt": "2019-07-11 19:30:16"
    },
    {
        "title": "Python操作MongoDB数据库",
        "author": "阿星Plus",
        "url": "2019-07-12-pymongo",
        "markdown": "### MongoDB 原生语句\n\n[MongoDB Shell 命令](/mongodb/mongodb.md)\n\n### 安装pymongo\n\n```pip install pymongo```\n\n### Python连接MongoDB\n\n```python\nimport pymongo\n\n# mobgodb连接对象\nclient = pymongo.MongoClient('localhost', port=27017)\n\n# 获取数据库, 可以不用创建数据库\ndb = client.zhihu\n\n# 获取数据库中的集合\ncollection = db.qa\n\n# insert_one 写入数据\ncollection.insert_one({\n    \"username\":\"aaa\",\n    \"password\":'123456'\n})\n\n# insert_many 写入多条数据\ncollection.insert_many([\n    {\n        \"username\":\"aaa\",\n        \"age\":18\n    },\n    {\n        \"username\":\"bbb\",\n        \"age\":20\n    }\n])\n\n# find 查找所有数据\ncursor = collection.find()\nfor x in cursor:\n    print(x)\n\n# find_one 获取一条数据\nresult = collection.find_one()\nprint(result)\n# 添加查询条件\nresult = collection.find_one({\"age\":18})\nprint(result)\n\n# 更新数据\ncollection.update_one({\"username\":\"bbb\"},{\"$set\":{\"username\":\"spider\"}})\n\n# 更新多条数据\ncollection.update_many({\"username\":\"aaa\"},{\"$set\":{\"username\":\"spider\"}})\n\n# 删除一条数据\ncollection.delete_one({\"age\":18})\n\n# 删除多条数据\ncollection.delete_many({\"username\":'spider'})\n```\n",
        "category": "Python",
        "tag": [
            "数据存储",
            "MongoDB"
        ],
        "createdAt": "2019-07-12 20:40:18"
    },
    {
        "title": "多线程爬虫",
        "author": "阿星Plus",
        "url": "2019-07-13-multithreading",
        "markdown": "有些时候，比如下载图片，是一个比较耗时的操作，如果采用同步的方式去下载，效率肯定会特别慢，这时候我们就可以考虑使用多线程的方式来下载图片\n\n### 多线程介绍\n\n- 多线程是为了同步完成多项任务，通过提高资源使用效率来进一步提高系统的效率\n- 线程是在同一时间需要完成多项任务的时候实现的\n- 最简单的比喻，多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，火车可以有多节车厢\n- 多线程的出现就是为了提高效率……\n\n### threading模块\n\nthreading模块是python中专门提供用来做多线程编程的模块，threading模块中最常用的类是Thread\n\n```python\nimport threading\nimport time\n\ndef coding():\n    for x in range(3):\n        print(\"coding %s\" % x)\n        time.sleep(1)\n\ndef drawing():\n    for x in range(3):\n        print(\"drawing %s\" % x)\n        time.sleep(1)\n\ndef single_thread():\n    coding()\n    drawing()\n\ndef multi_thread():\n    t1 = threading.Thread(target=coding)\n    t2 = threading.Thread(target=drawing)\n\n    t1.start()\n    t2.start()\n\nif __name__ == \"__main__\":\n    multi_thread()\n```\n\n### 查看线程函数\n\n使用 ```threading.enumerate()``` 函数可以看到当前线程的数量\n\n### 查看当前线程的名字\n\n使用 ```threading.current_thread()``` 可以看到当前线程的信息\n\n### 继承自 threading.Thread 类\n\n为了让线程代码更好的封装，可以使用 threading 模块下的 Thread 类，继承自这个类然后实现 run  方法，线程就会自动运行 run 方法中的代码\n\n```python\nimport threading\nimport time\n\nclass CodingThread(threading.Thread):\n    def run(self):\n        for x in range(3):\n            print(\"coding %s\" % threading.current_thread())\n            time.sleep(1)\n\nclass DrawingThread(threading.Thread):\n    def run(self):\n        for x in range(3):\n            print(\"drawing %s\" % threading.current_thread())\n            time.sleep(1)\n\ndef multi_thread():\n    t1 = CodingThread()\n    t2 = DrawingThread()\n\n    t1.start()\n    t2.start()\n\nif __name__ == \"__main__\":\n    multi_thread()\n```\n\n### 多线程共享全局变量的问题\n\n多线程都是在同一个进程中运行的，因此在进程中的全局变量所有线程都是可以共享的，这就会造成一个问题，因为线程执行的顺序是无序的，有可能就会导致数据错误，比如下面代码\n\n```python\nimport threading\n\nVALUE = 0\n\ndef add_value():\n    global VALUE\n    for x in range(1000000):\n        VALUE += 1\n    print(VALUE)\n\ndef main():\n    for x in range(2):\n        t = threading.Thread(target=add_value)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n以上代码结果正常来讲应该是2000000，但是因为多线程运行的不确定性，因此最后的结果可能是随机的，于是我们可以使用锁机制解决这个问题\n\n### 锁机制\n\n为了解决以上使用共享全局变量的问题，threading 提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，知道当前线程处理完成后，把锁释放，其他线程才能进来处理\n\n```python\nimport threading\n\nVALUE = 0\n\nlock =  threading.Lock()\n\ndef add_value():\n    global VALUE\n    lock.acquire()\n    for x in range(1000000):\n        VALUE += 1\n    lock.release()\n    \n    print(VALUE)\n\ndef main():\n    for x in range(2):\n        t = threading.Thread(target=add_value)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Lock 版生产者和消费者模式\n\n生产者和消费者模式是多线程开发中经常遇见的一种模式，生产者的线程专门用来生产数据，然后放到中间变量中，消费者再从这个中间的变量中取出数据进行消费，但是因为要使用中间变量，中间变量经常是全局变量，因为需要用锁来保证数据的完整性。\n\n使用 ```threading.Lock``` 锁实现 生产者和消费者模式例子\n\n```python\nimport threading\nimport time\nimport random\n\ngMoney = 1000\ngLock = threading.Lock()\ngTotalTimes = 10\ngTimes = 0\n\nclass Producer(threading.Thread):\n    def run(self):\n        global gMoney\n        global gTimes\n        while True:\n            money = random.randint(100, 1000)\n            gLock.acquire()\n            if gTimes >= gTotalTimes:\n                gLock.release()\n                break\n            gMoney += money\n            print('%s 生产了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gTimes += 1\n            gLock.release()\n            time.sleep(0.5)\n\nclass Consumer(threading.Thread):\n    def run(self):\n        global gMoney\n        while True:\n            money = random.randint(100, 1000)\n            gLock.acquire()\n            if gMoney >= money:\n                gMoney -= money\n                print('%s消费者消费了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            else:\n                if gTimes >= gTotalTimes:\n                    gLock.release()\n                    break\n                print('%s消费者准备消费%d元钱，剩余%d元钱，不足！' % (threading.current_thread(), money, gMoney))\n            gLock.release()\n            time.sleep(0.5)\n\ndef main():\n    for x in range(3):\n        t = Consumer(name='消费者线程%d' % x)\n        t.start()\n\n    for x in range(5):\n        t = Producer(name='生产者线程%d' % x)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Condition 版生产者与消费者模式\n\n就上面的例子，Lock版本的生产者与消费者模式可以正常的运行，但是存在一些不足，在消费者中总是通过 while-True 死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源行为，因为这种方式不是最好的解决方法，还有一种更好的方式就是使用 ```threading.Condition``` 来实现\n\n```threading.Condition``` 可以在没有数据的时候处于阻塞等待状态，一旦有合适的数据了，还可以使用 ```notify``` 相关的函数来通知其他处于等待的线程，这样就可以不用做一些无用的上锁和解锁操作，从而可以提高程序的性能\n\n```threading.Condition``` 类是 ```threading.Lock``` ，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁\n\n- acquire：上锁\n- release：解锁\n- wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码\n- notify：通知某个正在等待的线程，默认是第一个等待的线程\n- notify_all：通知所有正在等待的线程，notify和notify_all不会释放锁。并且需要在release之前调用\n\n使用 ```threading.Condition``` 实现生产者和消费者模式例子\n\n```python\nimport threading\nimport time\nimport random\n\ngMoney = 1000\ngCondition = threading.Condition()\ngTotalTimes = 10\ngTimes = 0\n\nclass Producer(threading.Thread):\n    def run(self):\n        global gMoney\n        global gTimes\n        while True:\n            money = random.randint(100, 1000)\n            gCondition.acquire()\n            if gTimes >= gTotalTimes:\n                gCondition.release()\n                break\n            gMoney += money\n            print('%s 生产了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gTimes += 1\n            gCondition.notify_all()\n            gCondition.release()\n            time.sleep(0.5)\n\nclass Consumer(threading.Thread):\n    def run(self):\n        global gMoney\n        while True:\n            money = random.randint(100, 1000)\n            gCondition.acquire()\n            while gMoney < money:\n                if gTimes >= gTotalTimes:\n                    gCondition.release()\n                    return\n                else:\n                    print('%s消费者准备消费%d元钱，剩余%d元钱，不足！' % (threading.current_thread(), money, gMoney))\n                gCondition.wait()\n            gMoney -= money\n            print('%s消费了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gCondition.release()\n            time.sleep(0.5)\n\ndef main():\n    for x in range(3):\n        t = Consumer(name='消费者线程%d' % x)\n        t.start()\n\n    for x in range(5):\n        t = Producer(name='生产者线程%d' % x)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Queue线程安全队列\n\n在线程中，访问一些全局变量，加锁是一个经常的过程，如果先把一些数据存储在某个队列中，那么python内置了一个线程安全的模块叫做queue模块，python中的queue模块提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列Queue，LIFO(后入先出)队列LifeQueue。这些队列都实现了锁原语(可以理解为原子操作，要么不做，要么都做完)，能够在多线程中直接使用，可以使用队列来实现线程间的同步\n\n- 初始化Queue(maxsize)：创建一个先进先出的队列\n- qsize()：返回队列的大小\n- empty()：判断队列是否为空\n- full()：判断队列是否满了\n- get()：从队列中取最后一个数据\n- put()：将一个数据放到队列中\n\n### 使用生产者与消费者模式多线程下载 斗图啦 表情包\n\n```python\nimport os\nimport re\nimport threading\nfrom queue import Queue\nfrom urllib import request\n\nimport requests\nfrom lxml import etree\n\nclass Procuder(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n\n    def __init__(self, page_queue, img_queue, *args, **kwargs):\n        super(Procuder,self).__init__(*args, **kwargs)\n        self.page_queue = page_queue\n        self.img_queue = img_queue\n\n    def run(self):\n        while True:\n            if self.page_queue.empty():\n                break\n            url = self.page_queue.get()\n            self.parse_page(url)\n\n    def parse_page(self, url):\n        response = requests.get(url,headers=self.headers)\n        text = response.text\n        html = etree.HTML(text)\n\n        imgs = html.xpath('//div[@class=\"page-content text-center\"]//img[@class!=\"gif\"]')\n        for img in imgs:\n            img_url = img.get('data-original')\n            img_name = img.get('alt')\n            img_name = re.sub(r'[\\?？\\.，。！!；;\\*]', '', img_name)\n\n            img_suffix = os.path.splitext(img_url)[1]\n            filename = img_name + img_suffix\n            self.img_queue.put((img_url, filename))\n\nclass Consumer(threading.Thread):\n    def __init__(self, page_queue, img_queue, *args, **kwargs):\n        super(Consumer,self).__init__(*args, **kwargs)\n        self.page_queue = page_queue\n        self.img_queue = img_queue\n\n    def run(self):\n        while True:\n            if self.img_queue.empty() and self.page_queue.empty():\n                break\n            img_url, filename = self.img_queue.get()\n            request.urlretrieve(img_url, 'images/' + filename)\n            print(filename + ' 下载完成!')\n\ndef main():\n    page_queue = Queue(100)\n    img_queue = Queue(1000)\n\n    for x in range(1, 101):\n        url = 'https://www.doutula.com/photo/list/?page=%d' % x\n        page_queue.put(url)\n\n    for x in range(5):\n        t = Procuder(page_queue, img_queue)\n        t.start()\n    for x in range(5):\n        t = Consumer(page_queue, img_queue)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### GIL全局解释器锁\n\nPython自带的解释器是CPython，CPython解释器的多线程实际上并非真正的多线程(在多核CPU中，只能利用一核，不能利用多核)。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中有一个东西叫做 GIL(Global Intepreter Lock)，叫做全局解释器，这个解释器锁是有必要的，因为CPython解释器的内存管理不是线程安全的，当然除了CPython解释器，还有其他解释器，有些解释器是没有GIL锁的\n\n- Jython：用Java实现的Python解释器。不存在GIL锁\n- IronPython：用.net实现的Python解释器。不存在GIL锁\n- PyPy：用Python实现的Python解释器。存在GIL锁\n\nGIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程\n\n### 多线程爬取百思不得姐段子数据\n\n```python\nimport csv\nimport threading\nfrom queue import Queue\n\nimport requests\nfrom lxml import etree\n\n\nclass budejieSpider(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n    def __init__(self, page_queue, joke_queue, *args,  **kwargs):\n        super(budejieSpider, self).__init__(*args,  **kwargs)\n        self.base_domain = \"http://www.budejie.com\"\n        self.page_queue = page_queue\n        self.joke_queue = joke_queue\n\n    def run(self):\n        while True:\n            if self.page_queue.empty():\n                break\n            url = self.page_queue.get()\n            response = requests.get(url, headers=self.headers)\n            text = response.text\n            html = etree.HTML(text)\n            descs = html.xpath(\"//div[@class='j-r-list-c-desc']\")\n            for desc in descs:\n                jokes = desc.xpath(\".//text()\")\n                joke = \"\\n\".join(jokes).strip()\n                link = self.base_domain+desc.xpath(\".//a/@href\")[0]\n                self.joke_queue.put((joke, link))\n            print('第%s页下载完成！' % url.split('/')[-1])\n\nclass budejieWriter(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n\n    def __init__(self, joke_queue, writer, gLock, *args,  **kwargs):\n        super(budejieWriter, self).__init__(*args,  **kwargs)\n        self.joke_queue = joke_queue\n        self.writer = writer\n        self.lock = gLock\n\n    def run(self):\n        while True:\n            try:\n                joke_info = self.joke_queue.get(timeout=40)\n                joke, link = joke_info\n                self.lock.acquire()\n                self.writer.writerow((joke, link))\n                self.lock.release()\n                print('保存一条.')\n            except:\n                pass\n\ndef main():\n    page_queue = Queue(10)\n    joke_queue = Queue(500)\n    gLock = threading.Lock()\n    fp = open('budejie.csv', 'a', newline='', encoding='utf-8')\n    writer = csv.writer(fp)\n    writer.writerow(('content', 'link'))\n\n    for x in range(1, 11):\n        url = 'http://www.budejie.com/text/%d' % x\n        page_queue.put(url)\n\n    for x in range(5):\n        t = budejieSpider(page_queue, joke_queue)\n        t.start()\n\n    for x  in range(5):\n        t = budejieWriter(joke_queue, writer, gLock)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n",
        "category": "Python",
        "tag": [
            "爬虫进阶",
            "多线程",
            "threading"
        ],
        "createdAt": "2019-07-13 21:50:34"
    },
    {
        "title": "动态网页爬虫",
        "author": "阿星Plus",
        "url": "2019-07-14-selenium",
        "markdown": "### Ajax是什么\n\nAJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是XML语法。因此叫做AJAX，其实现在数据交互基本上都是使用JSON。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在右键->查看网页源代码还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码\n\n### 获取Ajax数据的方式\n\n- 直接分析ajax调用的接口。然后通过代码请求这个接口\n- 使用 ```selenium``` + ```chromedriver``` 模拟浏览器行为获取数据\n\n\n| 方式 | 优点 | 缺点 |\n| :--- | :--- | :--- |\n| 分析接口 | 直接可以请求到数据，不需要做任何解析工作，代码量少，性能高 | 分析接口比较复杂，特别是一些通过js混淆的接口，容易被发现是爬虫 |\n| selenium | 直接模拟浏览器的行为，浏览器可以请求到的，使用 selenium 也能请求到，比较稳定 | 代码量多，性能低 |\n\n### ```selenium``` + ```chromedriver``` 获取动态数据\n\nselenium相当于是一个机器人，可以模拟人在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等\n\nchromedriver是一个驱动chrome浏览器的驱动程序，使用他才可以驱动浏览器，针对不同的浏览器有不同的driver\n\n- Chrome：https://sites.google.com/a/chromium.org/chromedriver/downloads\n- Firefox：https://github.com/mozilla/geckodriver/releases\n- Edge：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n- Safari：https://webkit.org/blog/6900/webdriver-support-in-safari-10/\n\n### 安装 ```selenium``` + ```chromedriver```\n\n- 安装selenium：selenium有很多语言的版本，有java、ruby、python等 ``` pip install selenium```\n- 安装chromedriver：下载和自己浏览器版本对应的文件，放到不需要权限的纯英文目录下就可以了\n\n### 简单使用\n\n以一个简单的获取百度首页的例子使用 selenium和chromedriver\n\n```python\nfrom selenium import webdriver\n\n# chromedriver的绝对路径\ndriver_path = r'D:\\Program Files\\chromedriver\\chromedriver.exe'\n\n# 初始化一个driver，并且指定chromedriver的路径\ndriver = webdriver.Chrome(executable_path=driver_path)\n\n# 请求网页\ndriver.get('https://www.meowv.com/')\n\n# 通过page_source获取网页源代码\nprint(driver.page_source)\n```\n\n### selenium 常用的操作\n\n官方文档：https://selenium-python.readthedocs.io/installation.html#introduction\n\n#### 关闭页面\n\n- ```driver.close()```：关闭当前页面\n- ```driver.quit()```：退出整个浏览器\n\n#### 定位元素\n\n- ```find_element_by_id```：根据id来查找某个元素\n\n```python\nsubmitTag = driver.find_element_by_id('su')\nsubmitTag1 = driver.find_element(By.ID,'su')\n```\n\n- ```find_element_by_class_name```：根据类名查找元素\n\n```python\nsubmitTag = driver.find_element_by_class_name('su')\nsubmitTag1 = driver.find_element(By.CLASS_NAME,'su')\n```\n\n- ```find_element_by_name```：根据name属性的值来查找元素\n\n```python\nsubmitTag = driver.find_element_by_name('email')\nsubmitTag1 = driver.find_element(By.NAME,'email')\n```\n\n- ```find_element_by_tag_name```：根据标签名来查找元素\n\n```python\nsubmitTag = driver.find_element_by_tag_name('div')\nsubmitTag1 = driver.find_element(By.TAG_NAME,'div')\n```\n\n- ```find_element_by_xpath```：根据xpath语法来获取元素\n\n```python\nsubmitTag = driver.find_element_by_xpath('//div')\nsubmitTag1 = driver.find_element(By.XPATH,'//div')\n```\n\n- ```find_element_by_css_selector```：根据css选择器选择元素\n\n```python\nsubmitTag = driver.find_element_by_css_selector('//div')\nsubmitTag1 = driver.find_element(By.CSS_SELECTOR,'//div')\n```\n\n- ```find_element``` 是获取第一个满足条件的元素\n- ```find_elements``` 是获取所有满足条件的元素\n\n#### 操作表单元素\n\n- 操作输入框：分为两步。第一步：找到这个元素。第二步：使用```send_keys(value)```，将数据填充进去\n\n```python\ninputTag = driver.find_element_by_id('kw')\ninputTag.send_keys('python')\n```\n\n使用```clear```方法可以清除输入框中的内容 ```inputTag.clear()```\n\n- 操作checkbox：因为要选中checkbox标签，在网页中是通过鼠标点击的。因此想要选中checkbox标签，那么先选中这个标签，然后执行click事件\n\n```python\nrememberTag = driver.find_element_by_name(\"rememberMe\")\nrememberTag.click()\n```\n\n- 选择select：select元素不能直接点击。因为点击后还需要选中元素。这时候selenium就专门为select标签提供了一个类selenium.webdriver.support.ui.Select。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了\n\n```python\nfrom selenium.webdriver.support.ui import Select\n# 选中这个标签，然后使用Select创建对象\nselectTag = Select(driver.find_element_by_id(\"city-select\"))\n# 根据索引选择\nselectTag.select_by_index(1)\n# 根据值选择\nselectTag.select_by_value(\"https://news.hao123.com/wangzhi\")\n# 根据可视的文本选择\nselectTag.select_by_visible_text(\"上海\")\n# 取消选中所有选项\nselectTag.deselect_all()\n```\n\n- 操作按钮：操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用click函数就可以了\n\n```python\ninputTag = driver.find_element_by_id('su')\ninputTag.click()\n```\n\n#### 行为链\n\n有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件\n\n```python\ninputTag = driver.find_element_by_id('kw')\nsubmitTag = driver.find_element_by_id('su')\n\nactions = ActionChains(driver)\nactions.move_to_element(inputTag)\nactions.send_keys_to_element(inputTag,'python')\nactions.move_to_element(submitTag)\nactions.click(submitTag)\nactions.perform()\n```\n\n还有更多的鼠标相关的操作\n\n- ```click_and_hold(element)```：点击但不松开鼠标\n- ```context_click(element)```：右键点击\n- ```double_click(element)```：双击\n- 更多方法请参考：http://selenium-python.readthedocs.io/api.html\n\n#### Cookie操作\n\n- 获取所有的cookie\n\n```python\nfor cookie in driver.get_cookies():\n    print(cookie)\n```\n\n-根据cookie的key获取value\n\n```python\nvalue = driver.get_cookie(key)\n```\n\n- 删除所有的cookie：\n\n```python\ndriver.delete_all_cookies()\n```\n\n- 删除某个cookie：\n\n```python\ndriver.delete_cookie(key)\n```\n\n#### 页面等待\n\n现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。为了解决这个问题。所以 selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。\n\n- 隐式等待：调用driver.implicitly_wait。那么在获取不可用的元素之前，会先等待10秒中的时间。\n\n```python\ndriver = webdriver.Chrome(executable_path=driver_path)\ndriver.implicitly_wait(10)\n# 请求网页\ndriver.get(\"https://www.douban.com/\")\n```\n\n- 显示等待：显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用selenium.webdriver.support.excepted_conditions期望的条件和selenium.webdriver.support.ui.WebDriverWait来配合完成.\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\ndriver_path = r'D:\\Program Files\\chromedriver\\chromedriver.exe'\ndriver = webdriver.Chrome(executable_path=driver_path)\n\ndriver.get('https://www.douban.com/')\ndriver.implicitly_wait(20)\n\nelement = WebDriverWait(driver, 10).until(\n    EC.presence_of_element_located((By.NAME, 'phone'))\n)\nprint(element)\n```\n\n- 一些其他的等待条件\n    - ```presence_of_element_located```：某个元素已经加载完毕了\n    - ```presence_of_all_emement_located```：网页中所有满足条件的元素都加载完毕了\n    - ```element_to_be_cliable```：某个元素是可以点击了\n    - 更多条件请参考：http://selenium-python.readthedocs.io/waits.html\n\n#### 切换页面\n\n有时候窗口中有很多子tab页面。这时候肯定是需要进行切换的。selenium提供了一个叫做switch_to_window来进行切换，具体切换到哪个页面，可以从driver.window_handles中找到。\n\n```python\n# 打开一个新的页面\nself.driver.execute_script(\"window.open('\"+url+\"')\")\n# 切换到这个新的页面中\nself.driver.switch_to_window(self.driver.window_handles[1])\n```\n\n#### 设置代理ip\n\n有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以Chrome浏览器为例\n\n```python\nfrom selenium import webdriver\n\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--proxy-server=http://132.232.126.92:8888\")\ndriver_path = r\"D:\\Program Files\\chromedriver\\chromedriver.exe\"\ndriver = webdriver.Chrome(executable_path=driver_path,chrome_options=options)\n\ndriver.get('http://httpbin.org/ip')\n```\n\n#### WebElement元素\n\nfrom selenium.webdriver.remote.webelement import WebElement类是每个获取出来的元素的所属类，它有一些常用的属性\n\n- get_attribute：这个标签的某个属性的值\n- screentshot：获取当前页面的截图，这个方法只能在driver上使用，driver的对象类，是继承自WebElement\n",
        "category": "Python",
        "tag": [
            "ip代理",
            "cookie",
            "爬虫进阶",
            "ajax",
            "selenium",
            "ChromeDriver"
        ],
        "createdAt": "2019-07-14 22:33:36"
    },
    {
        "title": "图形验证码识别",
        "author": "阿星Plus",
        "url": "2019-07-15-pytesseract",
        "markdown": "### 图形验证码识别技术\n\n阻碍我们爬虫的。有时候正是在登录或者请求一些数据时候的图形验证码。因此这里我们讲解一种能将图片翻译成文字的技术。将图片翻译成文字一般被成为光学文字识别（Optical Character Recognition），简写为OCR。实现OCR的库不是很多，特别是开源的。因为这块存在一定的技术壁垒（需要大量的数据、算法、机器学习、深度学习知识等），并且如果做好了具有很高的商业价值。因此开源的比较少。这里介绍一个比较优秀的图像识别开源库：Tesseract。\n\n### Tesseract\n\nTesseract是一个OCR库，目前由谷歌赞助。Tesseract是目前公认最优秀、最准确的开源OCR库。Tesseract具有很高的识别度，也具有很高的灵活性，他可以通过训练识别任何字体。\n\n### 安装\n\n#### Windows\n\n在 https://github.com/tesseract-ocr/ 下载可执行文件，然后一顿点击下一步安装即可，放在不需要权限的纯英文路径下\n\n#### Linux\n\n可以在 https://github.com/tesseract-ocr/tesseract/wiki/Compiling 下载源码自行编译，或者(ubuntu下)通过以下命令进行安装 ```sudo apt install tesseract-ocr```\n\n#### Mac\n\n用Homebrew即可方便安装，```brew install tesseract```\n\n### 设置环境变量\n\n安装完成后，如果想要在命令行中使用Tesseract，那么应该设置环境变量。Mac和Linux在安装的时候就默认已经设置好了。在Windows下把tesseract.exe所在的路径添加到PATH环境变量中。\n\n还有一个环境变量需要设置的是，要把训练的数据文件路径也放到环境变量中\n\n在环境变量中，添加一个 TESSDATA_PREFIX=~~~\\teseractdata\n\n### 在命令行中使用tesseract识别图像\n\n如果想要在cmd下能够使用tesseract命令，那么需要把tesseract.exe所在的目录放到PATH环境变量中。然后使用命令：tesseract 图片路径 文件路径。\n\n```tesseract a.png a```\n\n那么就会识别出a.png中的图片，并且把文字写入到a.txt中。如果不想写入文件直接想显示在终端，那么不要加文件名就可以了。\n\n### 在代码中使用tesseract识别图像\n\n在Python代码中操作tesseract。需要安装一个库，叫做pytesseract。通过pip的方式即可安装：\n\n```pip install pytesseract```\n\n并且，需要读取图片，需要借助一个第三方库叫做PIL。通过pip list看下是否安装。如果没有安装，通过pip的方式安装：\n\n```pip install PIL```\n\n使用pytesseract将图片上的文字转换为文本文字\n\n```python\n# 导入pytesseract库\nimport pytesseract\n# 导入Image库\nfrom PIL import Image\n\n# 指定tesseract.exe所在的路径\npytesseract.pytesseract.tesseract_cmd = r'D:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n\n# 打开图片\nimage = Image.open(\"a.png\")\n# 调用image_to_string将图片转换为文字\ntext = pytesseract.image_to_string(image, lang='chi_sim')\nprint(text)\n```\n\n### 用pytesseract自动识别图形验证码\n\n```python\nimport time\nfrom urllib import request\n\nimport pytesseract\nfrom PIL import Image\n\ndef main():\n    pytesseract.pytesseract.tesseract_cmd = r'D:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n    while True:\n        url = 'https://e.coding.net/api/getCaptcha'\n        request.urlretrieve(url, 'captcha.png')\n        image = Image.open('captcha.png')\n        text = pytesseract.image_to_string(image)\n        print(text)\n        time.sleep(2)\n\nif __name__ == \"__main__\":\n    main()\n```\n",
        "category": "Python",
        "tag": [
            "爬虫进阶",
            "验证码",
            "tesseract",
            "pytesseract"
        ],
        "createdAt": "2019-07-15 23:21:38"
    },
    {
        "title": "Scrapy框架",
        "author": "阿星Plus",
        "url": "2019-07-16-scrapy",
        "markdown": "### Scrapy框架介绍\n\n写一个爬虫，需要做很多的事情，比如：发送网络请求、数据解析、数据存储、反反爬虫机制(ip代理，设置请求头等)、异步请求等等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此scrapy把一些基础的东西都封装好了，在scrapy框架上开发爬虫可以变得更加的高效，爬取效率和开发效率得到提升。\n\n### Scrapy框架模块功能\n\n- Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。\n- Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是我们需要的，都是由程序员自己决定。\n- Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。\n- Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。\n- Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。\n- Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。\n- Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。\n\n### Scrapy安装和文档\n\n- 安装：通过 ```pip install scrapy``` 即可安装。\n    - 在ubuntu上安装scrapy之前，需要先安装以下依赖：```sudo apt-get install python3-dev build-essential python3-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-dev```，然后再通过 ```pip install scrapy``` 安装。\n    - 如果在windows系统下，提示这个错误ModuleNotFoundError: No module named 'win32api'，那么使用以下命令可以解决：```pip install pypiwin32```。\n- Scrapy官方文档：http://doc.scrapy.org/en/latest\n- Scrapy中文文档：http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html\n\n### Scrapy快速入门\n\n#### 创建项目\n\n要使用Scrapy框架创建项目，需要通过命令来创建。首先进入到你想把这个项目存放的目录。然后使用以下命令创建：\n\n```scrapy startproject [项目名称]```\n\n#### 目录结构介绍\n\n- items.py：用来存放爬虫爬取下来数据的模型。\n- middlewares.py：用来存放各种中间件的文件。\n- pipelines.py：用来将items的模型存储到本地磁盘中。\n- settings.py：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）。\n- scrapy.cfg：项目的配置文件。\n- spiders包：以后所有的爬虫，都是存放到这个里面。\n\n#### 使用Scrapy框架爬取糗事百科段子例子\n\n##### 使用命令创建一个爬虫\n\n```scrapy gensipder qsbk \"qiushibaike.com\"```\n\n创建了一个名字叫做 qsbk 的爬虫，并且能爬取的网页只会限制在 qiushibaike.com 这个域名下。\n\n##### 爬虫代码解析\n\n```python\nimport scrapy\n\nclass QsbkSpider(scrapy.Spider):\n    name = 'qsbk'\n    allowed_domains = ['qiushibaike.com']\n    start_urls = ['http://qiushibaike.com/']\n\n    def parse(self, response):\n        pass\n```\n\n其实这些代码我们完全可以自己手动去写，而不用命令。只不过是不用命令，自己写这些代码比较麻烦。\n\n要创建一个Spider，那么必须自定义一个类，继承自scrapy.Spider，然后在这个类中定义三个属性和一个方法。\n\n- name：这个爬虫的名字，名字必须是唯一的。\n- allow_domains：允许的域名。爬虫只会爬取这个域名下的网页，其他不是这个域名下的网页会被自动忽略。\n- start_urls：爬虫从这个变量中的url开始。\n- parse：引擎会把下载器下载回来的数据扔给爬虫解析，爬虫再把数据传给这个parse方法。这个是个固定的写法。这个方法的作用有两个，第一个是提取想要的数据。第二个是生成下一个请求的url。\n\n##### 修改settings.py代码\n\n在做一个爬虫之前，一定要记得修改setttings.py中的设置。两个地方是强烈建议设置的。\n\n- ROBOTSTXT_OBEY设置为False。默认是True。即遵守机器协议，那么在爬虫的时候，scrapy首先去找robots.txt文件，如果没有找到。则直接停止爬取。\n- DEFAULT_REQUEST_HEADERS添加User-Agent。这个也是告诉服务器，我这个请求是一个正常的请求，不是一个爬虫。\n\n##### 完成的爬虫代码\n\n###### 爬虫部分代码\n\n```python\nimport scrapy\nfrom scrapy.http.response.html import HtmlResponse\nfrom scrapy.selector.unified import SelectorList\nfrom qsbk.items import QsbkItem\n\nclass QsbkSpider(scrapy.Spider):\n    name = 'qsbk_spider'\n    allowed_domains = ['qiushibaike.com']\n    start_urls = ['https://www.qiushibaike.com/text/page/1/']\n    base_domain = 'https://www.qiushibaike.com'\n\n    def parse(self, response):\n        duanziDivs = contentLeft = response.xpath(\"//div[@id='content-left']/div\")\n        for duanzidiv in duanziDivs:\n            author = duanzidiv.xpath(\".//h2/text()\").get().strip()\n            content = duanzidiv.xpath(\".//div[@class='content']//text()\").getall()\n            content = \"\".join(content).strip()\n\n            # duanzi = {\"author\":author,\"content\":content}\n            # yield duanzi\n\n            item = QsbkItem(author=author,content=content)\n            yield item\n        next_url = response.xpath(\"//ul[@class='pagination']/li[last()]/a/@href\").get()\n        if not next_url:\n            return\n        else:\n            yield scrapy.Request(self.base_domain + next_url, self.parse)\n```\n\n###### items.py部分代码\n\n```python\nimport scrapy\n\nclass QsbkItem(scrapy.Item):\n    author = scrapy.Field()\n    content = scrapy.Field()\n```\n\n###### pipeline部分代码\n\n```python\n# 方式1\nimport json\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'w', encoding='utf-8')\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        item_json = json.dumps(dict(item), ensure_ascii=False)\n        self.fp.write(item_json+ '\\n')\n        return item\n\n    def close_spider(self, spider):\n        self.fp.close()\n        print('end...')\n\n# 方式2\nfrom scrapy.exporters import JsonItemExporter\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'wb')\n        self.exporter = JsonItemExporter(self.fp, ensure_ascii=False, encoding='utf-8')\n        self.exporter.start_exporting()\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n\n    def close_spider(self, spider):\n        self.exporter.finish_exporting()\n        self.fp.close()\n        print('end...')\n\n# 方式3\nfrom scrapy.exporters import JsonLinesItemExporter\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'wb')\n        self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding='utf-8')\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n\n    def close_spider(self, spider):\n        self.fp.close()\n        print('end...')\n```\n\n##### 运行scrapy项目\n\n运行scrapy项目。需要在终端，进入项目所在的路径，然后 ```scrapy crawl [爬虫名字]``` 即可运行指定的爬虫。如果不想每次都在命令行中运行，那么可以把这个命令写在一个文件中。以后就在pycharm中执行运行这个文件就可以了。比如现在新创建一个文件叫做 start.py，然后在这个文件中填入以下代码：\n\n```python\nfrom scrapy import cmdline\n\ncmdline.execute(\"scrapy crawl qsbk\".split())\n```\n\n### JsonItemExporter和JsonLinesItemExporter\n\n- 保存json数据的时候，可以使用这两个类，让操作变得更简单\n- `JsonItemExporter`：每次把数据添加到内存中，最后统一写入磁盘，存储的数据是一个满足json规则的数据，数据量比较大，比较耗内存\n- `JsonLinesItemExporter`：每次调用`export_item`的时候把这个item存储到磁盘，每一个字典是一行，整个文件不是一个满足json格式的文件，每次处理初级的时候直接存储到硬盘，不耗内存，数据比较安全\n\n### Scrapy爬虫注意事项\n\n- response 是一个`from scrapy.http.response.html.HtmlResponse`对象，可以执行`xpath`和`css`语法提取数据\n- 提取出来的数据是一个`Selector`或者`SelectorList`对象，如果想要获取其中的字符串，应该执行`getall`或者`get`方法\n- getall方法：获取`Selector`中所有文本，返回的是一个列表\n- get方法：获取的是`Selector`中的第一个文本，返回的是str类型\n- 如果数据解析回来要传给pipelines处理，可以使用`yield`来返回，或者是添加所有的item，统一使用`return`返回\n- item：在`item.py`中定义好模型，不要使用字典\n- pipelines：这个是专门一从来保存数据的，其中有三个方法是会被经常用到的。要激活pipelines，应该在`settings.py`中，设置`ITEM_PIPELINES`\n    - `open_spider`：当爬虫被打开的时候执行\n    - `process_item`：当爬虫有item传过来的时候会被调用\n    - `close_spider`：当爬虫关闭的时候被调用\n\n### CrawlSpider\n\n在糗事百科的爬虫案例中。我们是自己在解析完整个页面后获取下一页的url，然后重新发送一个请求。有时候我们想要这样做，只要满足某个条件的url，都给我进行爬取。那么这时候我们就可以通过CrawlSpider来帮我们完成了。CrawlSpider继承自Spider，只不过是在之前的基础之上增加了新的功能，可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的yield Request。\n\n### 创建CrawlSpider爬虫\n\n之前创建爬虫的方式是通过```scrapy genspider [爬虫名字] [域名]```的方式创建的。如果想要创建CrawlSpider爬虫，那么应该通过以下命令创建：\n\n```scrapy genspider -c crawl [爬虫名字] [域名]```\n\n### LinkExtractors链接提取器\n\n使用LinkExtractors可以不用程序员自己提取想要的url，然后发送请求。这些工作都可以交给LinkExtractors，他会在所有爬的页面中找到满足规则的url，实现自动的爬取。\n\n```python\nclass scrapy.linkextractors.LinkExtractor(\n    allow = (),\n    deny = (),\n    allow_domains = (),\n    deny_domains = (),\n    deny_extensions = None,\n    restrict_xpaths = (),\n    tags = ('a','area'),\n    attrs = ('href'),\n    canonicalize = True,\n    unique = True,\n    process_value = None\n)\n```\n\n- allow：允许的url。所有满足这个正则表达式的url都会被提取。\n- deny：禁止的url。所有满足这个正则表达式的url都不会被提取。\n- allow_domains：允许的域名。只有在这个里面指定的域名的url才会被提取。\n- deny_domains：禁止的域名。所有在这个里面指定的域名的url都不会被提取。\n- restrict_xpaths：严格的xpath。和allow共同过滤链接。\n\n### Rule规则类\n\n定义爬虫的规则类。\n\n```python\nclass scrapy.spiders.Rule(\n    link_extractor,\n    callback = None,\n    cb_kwargs = None,\n    follow = None,\n    process_links = None,\n    process_request = None\n)\n```\n\n- link_extractor：一个LinkExtractor对象，用于定义爬取规则。\n- callback：满足这个规则的url，应该要执行哪个回调函数。因为CrawlSpider使用了parse作为回调函数，因此不要覆盖parse作为回调函数自己的回调函数。\n- follow：指定根据该规则从response中提取的链接是否需要跟进。\n- process_links：从link_extractor中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。\n\n### Scrapy Shell\n\n我们想要在爬虫中使用xpath、beautifulsoup、正则表达式、css选择器等来提取想要的数据。但是因为scrapy是一个比较重的框架。每次运行起来都要等待一段时间。因此要去验证我们写的提取规则是否正确，是一个比较麻烦的事情。因此Scrapy提供了一个shell，用来方便的测试规则\n\n打开cmd终端，进入到Scrapy项目所在的目录，然后进入到scrapy框架所在的虚拟环境中，输入命令```scrapy shell [链接]```。就会进入到scrapy的shell环境中。在这个环境中，你可以跟在爬虫的parse方法中一样使用了。\n",
        "category": "Python",
        "tag": [
            "爬虫进阶",
            "Scrapy"
        ],
        "createdAt": "2019-07-16 19:50:42"
    },
    {
        "title": "Scrapy-Redis分布式爬虫",
        "author": "阿星Plus",
        "url": "2019-07-17-scrapy-redis",
        "markdown": "## Scrapy-Redis分布式爬虫组件\n\nScrapy是一个框架，他本身是不支持分布式的。如果我们想要做分布式的爬虫，就需要借助一个组件叫做Scrapy-Redis，这个组件正是利用了Redis可以分布式的功能，集成到Scrapy框架中，使得爬虫可以进行分布式。可以充分的利用资源（多个ip、更多带宽、同步爬取）来提高爬虫的爬行效率。\n\n## 分布式爬虫的优点\n\n- 可以充分利用多台机器的带宽\n- 可以充分利用多台机器的ip地址\n- 多台机器做，爬取效率更高\n\n## 分布式爬虫必须要解决的问题\n\n- 分布式爬虫是好几台机器在同时运行，如何保证不同的机器爬取页面的时候不会出现重复爬取的问题\n- 分布式爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方\n\n## 安装\n\n通过 ```pip install scrapy-redis``` 即可安装\n\n## 将scrapy框架开发的爬虫项目改为分布式爬虫项目\n\n1. 将爬虫的类从```scrapy.Spider```变成```scrapy_redis.spiders.RedisSpider```，或者是从```scrapy.CrawlSpider```变成```scrapy_redis.spiders.RedisCrawlSpider```\n\n2. 将爬虫中的```start_urls```删掉，增加一个 ```redis_key=\"xxx\"``` 。这个```redis_key```是为了以后在redis中控制爬虫启动的。爬虫的第一个url，就是在redis中通过这个发送出去的。\n\n3. 在配置文件中增加如下配置\n\n    ```python\n        # Scrapy-Redis相关配置\n\n        # 确保request存储到redis中\n        SCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n\n        # 确保所有爬虫共享相同的去重指纹\n        DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n\n        # 设置redis为item pipeline\n        ITEM_PIPELINES = {\n            'scrapy_redis.pipelines.RedisPipeline': 300\n        }\n\n        # 在redis中保持scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能\n        SCHEDULER_PERSIST = True\n\n        # 设置连接redis信息\n        REDIS_HOST = '127.0.0.1'\n        REDIS_PORT = 6379\n    ```\n\n4. 运行爬虫\n    - 在爬虫服务器上，进入爬虫文件所在的路径，然后输入命令：```scrapy runspider [爬虫名字]```\n    - 在Redis服务器上，推入一个开始的url链接：```redis-cli> lpush [redis_key] start_url``` 开始爬取\n",
        "category": "Python",
        "tag": [
            "爬虫进阶",
            "Scrapy",
            "Redis",
            "分布式"
        ],
        "createdAt": "2019-07-17 20:18:30"
    },
    {
        "title": "移除Windows图标快捷方式小箭头",
        "author": "阿星Plus",
        "url": "2018-02-20-remove-shortcuts",
        "markdown": "以管理员身份运行 cmd，键入以下代码即可。\n\n```scheme\nreg delete \"HKEY_CLASSES_ROOT\\lnkfile\" /v IsShortcut /f & taskkill /f /im explorer.exe & start explorer.exe \n```\n",
        "category": "Other",
        "tag": [
            "Windows"
        ],
        "createdAt": "2018-02-20 18:22:00"
    },
    {
        "title": "计算机基础知识",
        "author": "阿星Plus",
        "url": "2015-11-20-computer-knowledge",
        "markdown": "# 计算机基础知识\n\n二进制数的运算方法，电子计算机具有强大的运算能力，它可以进行两种运算：算术运算和逻辑运算。\n\n## 二进制数的算术运算\n\n二进制数的算术运算包括：加、减、乘、除四则运算，下面分别予以介绍。\n\n### （1）二进制数的加法\n\n根据“逢二进一”规则，二进制数加法的法则为：\n\n```\n0＋0＝0\n0＋1＝1＋0＝1\n1＋1＝0　（进位为1）\n1＋1＋1＝1 （进位为1）\n```\n\n### （2）二进制数的减法\n\n根据“借一有二”的规则，二进制数减法的法则为：\n\n```\n0－0＝0\n1－1＝0\n1－0＝1\n0－1＝1 （借位为1）\n```\n\n### （3）二进制数的乘法\n\n二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有0或1两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为：\n\n```\n0×0＝0\n0×1＝1×0＝0\n1×1＝1\n```\n\n由低位到高位，用乘数的每一位去乘被乘数，若乘数的某一位为1，则该次部分积为被乘数；若乘数的某一位为0，则该次部分积为0。某次部分积的最低位必须和本位乘数对齐，所有部分积相加的结果则为相乘得到的乘积。\n\n### （4）二进制数的除法\n\n二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。\n\n## 二进制数的逻辑运算\n\n二进制数的逻辑运算包括逻辑加法（“或”运算）、逻辑乘法（“与”运算）、逻辑否定（“非”运算）和逻辑“异或”运算。\n\n### （1）逻辑“或”运算\n\n又称为逻辑加，可用符号“＋”或“∨”来表示。逻辑“或”运算的规则如下：\n\n```\n0＋0＝0或0∨0＝0\n0＋1＝1或0∨1＝1\n1＋0＝1或1∨0＝1\n1＋1＝1或1∨1＝1\n```\n\n可见，两个相“或”的逻辑变量中，只要有一个为1，“或”运算的结果就为1。仅当两个变量都为0时，或运算的结果才为0。计算时，要特别注意和算术运算的加法加以区别。\n\n### （2）逻辑“与”运算\n\n又称为逻辑乘，常用符号“×”或“· ”或“∧”表示。“与”运算遵循如下运算规则：\n\n```\n0×1＝0或0·1＝0或0∧1＝0\n1×0＝0或1·0＝0或1∧0＝0\n1×1＝1或1·1＝1或1∧1＝1\n```\n\n可见，两个相“与”的逻辑变量中，只要有一个为0，“与”运算的结果就为0。仅当两个变量都为1时，“与”运算的结果才为1。\n\n### （3）逻辑“非”运算\n\n又称为逻辑否定，实际上就是将原逻辑变量的状态求反，其运算规则如下：\n\n可见，在变量的上方加一横线表示“非”。逻辑变量为0时，“非”运算的结果为1。逻辑变量为1时，“非”运算的结果为0。\n\n### （4）逻辑“异或”运算\n\n“异或”运算，常用符号“”或“”来表示，其运算规则为：\n\n```\n00＝0 或 00＝0\n01＝1 或 01＝1\n10＝1 或 10＝1\n11＝0 或 11＝0\n```\n\n可见：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为0。取值相异时，“异或”的结果为1\n\n以上仅就逻辑变量只有一位的情况得到了逻辑“与”、“或”、“非”、“异或”运算的运算规则。当逻辑变量为多位时，可在两个逻辑变量对应位之间按上述规则进行运算。特别注意，所有的逻辑运算都是按位进行的，位与位之间没有任何联系，即不存在算术运算过程中的进位或借位关系。下面举例说明。\n\n- 【例】 如两变量的取值 X＝00FFH，Y＝5555H，求Z1＝X∧Y；Z2＝X∨Y；Z3＝；Z4＝XY的值。\n\n```\n解：\nX＝0000000011111111\nY＝0101010101010101\n则：\nZ1＝0000000001010101＝0055H\nZ2＝0101010111111111＝55FFH\nZ3＝1111111100000000＝FF00H\nZ4＝0101010110101010＝55AAH\n```\n\n## 数在计算机中的表示\n\n在计算机中要处理的数有无符号数和有符号数。这些数在计算机中是如何表示的呢？\n\n- 1．无符号数\n\n所谓无符号数，通常表示一个数的绝对值，即数的各位都用来表示数值的大小。一个字节（8位）二进制数只能表示0～255范围内的数。因此，要表示大于255的数，必须采用多个字节来表示，它的长度可以为任意倍字节长，其数据格式如图1.1所示。\n\n\n- 2．有符号数\n\n所谓有符号数，即用来表示一个任意位长的正数或负数。我们知道，在普通数字中，区分正负数是在数的绝对值前面加上符号来表示，即“＋”表示正数，“－”表示负数。在计算机中数的符号也数码化了，即用一位二进制数位来表示符号。一般是，用一个数的最高位来表示符号位，用“0”表示正号，用“1”表示负号，而其余位为数值位。其数据格式如图1.2所示。\n\n\n- 3．有符号数的原码、反码、补码及补码运算\n\n带正、负号的二进制数称为数的真值表示。\n\n```\n例如：X＝＋1010110\n　　　Y＝－0110101\n```\n\n为了运算方便，在计算机里的有符号数，有三种表示方法，即原码、反码和补码，称为机器数。\n\n### 原码\n\n正数的符号位用“0”表示，负数的符号位用“1”表示，其余数字位表示数值本身，这种表示法称为原码。\n\n例如：上例中\n\n```\n[X]原＝01010110\n[Y]原＝10110101\n```\n\n对于0，可以认为它是＋0，也可以认为它是－0。因此在原码中，0有下列两种表示\n\n```\n[＋0]原＝00000000\n[－0]原＝10000000\n```\n\n原码表示数的方法很简单，只需要在真值的基础上，将符号位用数码“0”和“1”表示即可。但采用原码表示的数在计算机中进行加减运算时很麻烦。如：遇到两个异号数相加，或两个同号数相减时，就要用减法运算。为了把减法运算转变成加法运算，则引入了反码和补码。\n\n### 反码\n\n在原码表示的基础上很容易求得一个数的反码。正数的反码与原码相同，而负数的反码则是在原码的基础上，符号位不变（仍为1），其余数位按位求反，即0→1，1→0。\n\n例如：上例中\n\n```\n[X]反＝01010110\n[Y]反＝11001010\n而：[＋0]反＝00000000\n　　[－0]反＝11111111\n```\n\n### 补码\n\n一个数的补码也很容易求得。如果是正数，补码同原码也同反码，如果是负数，则在反码的基础上最末位加1。\n\n例如：上例中\n\n```\n[X]补＝01010110＝[X]反＝[X]原 \n[Y]补＝11001011\n注：补码中0只有一种表示，无正负之分，即：\n[＋0]补＝[－0]补＝00000000\n不难证明，补码具有如下特性：\n[[X]补]补＝[X]原\n```\n\n用8位二进制数来表示无符号数及有符号数的原码、反码、补码时的对应关系见表1.5。\n\n由表1.5可知，用8位二进制数，表示无符号数为0～255；表示原码为－127～＋127；表示反码为－127～＋127；表示补码为－128～＋127。\n\n### 补码运算\n\n两个用补码表示的带符号数进行加减运算时，特点是把符号位上表示正负的“1”和“0”也看成数，与数值部分一同进行运算，所得的结果也为补码形式，即结果的符号位为“0”，表示正数，结果的符号位为“1”表示负数。下面分加、减两种情况予以讨论。\n两个带符号的数X和Y进行相加时，是将两个数分别转换为补码的形式，然后进行补码加运算，所得的结果为和的补码形式。即：\n\n```\n[X＋Y]补＝[X]补＋[Y]补\n```\n\n- 【例】 用补码进行下列运算 (＋18)＋(－15)；(－18)＋(＋15)；(－18)＋(－11)\n\n解：...\n\n由例1.2可知：当带符号的数采用补码形式进行相加时，可把符号位也当作普通数字一样与数值部分一起进行加法运算，若符号位上产生进位时，则自动丢掉，所得的结果为两数之和的补码形式。如果想得到运算后原码的结果，可对运算结果再求一次补码即可。\n\n### 两个带符号数相减，可通过下面的公式进行\n\n```\nX－Y＝X＋（－Y）\n则　[X－Y]补＝[X＋(－Y)]补＝[X]补＋[－Y]补\n```\n\n可见：求[X－Y]补，可以用[X]补和[－Y]补相加来实现。这里关键在于求[－Y]补。如果已知[Y]补，那么对[Y]补的每一位（包括符号位）都按位求反，然后再在末位加1，结果即为[－Y]补。（证明从略）。一般称[－Y]补为对[Y]补的“变补”，即[[Y]补]变补＝[－Y]补；已知[Y]补求[－Y]补的过程叫变补。\n这样一来，求两个带符号的二进制数之差，可以用“减数（补码）变补与被减数（补码）相加”来实现。这是补码表示法的主要优点之一。\n\n- 【例】 用补码进行下列运算：① 96－19； ② (－56)－(－17)\n\n```\n解：① X＝96，Y＝19 则[X]补＝01100000\n[Y]补＝00010011\n[－Y]补＝11101101故 [X－Y]补＝[X－Y]原＝01001101＝＋77\n```\n\n```\n② X＝－56，Y＝－17， 则\n[X]补＝11001000\n[Y]补＝11101111\n[－Y]补＝00010001\n则 [X－Y]补＝11011001\n故 [X－Y]原 ＝[[X－Y]补]补＝10100111＝－39\n综上所述，对于补码的加、减运算可用下边一般公式表示：\n[X±Y]补＝[X]补＋[±Y]补 （都小于2n+1）\n```\n\n### 溢出判断\n\n当两个有符号数进行补码运算时，若运算结果的绝对值超出运算装置容量时，数值部分就会发生溢出，占据符号位的位置，导致错误的结果。这种现象通常称为补码溢出，简称溢出。这和正常运算时符号位的进位自动丢失在性质上是不同的。下面举例说明。例如：某运算装置共有五位，除最高位表示符号位外，还有四位用来表示数值。先看下面两组运算。\n\n① 计算13＋7＝？\n\n② 计算(－4)＋(－4)＝？\n\n- ① 的运算结果显然是错误的，因为两个正数相加不可能得到负数的结果，产生错误的原因是由于两个数相加后的数值超出了加法装置所允许位数（数值部分4位，可以表示的最大数值为24＝16），因而从数值的最高位向符号位产生了进位，或说这种现象是由于“溢出”而造成的。\n- ② 的结果显然是正确的，由符号位产生的进位自动丢失。\n\n为了保证运算结果的正确性，计算机必须能够判别出是正常进位还是发生了溢出错误。\n微机中常用的溢出判别称为双高位判别法，并常用“异或”电路来实现溢出判别。\n\n## 数的编码方法\n\n在计算机里，所有用到的数字、字母、符号、指令等都必须用特定的二进制码来表示，这就是二进制编码。\n\n### 二进制编码的十进制数\n\n- 计算机只能识别二进制数，但是，人们却熟悉十进制数。所以，在计算机输入和输出数据时，往往采用十进制数表示。不过，这样的十进制数是用二进制编码表示的，称为二进制编码的十进制数——BCD（binary code decimal）码。\n- 用二进制数为十进制数编码，每一位十进制数需要由四位二进制数来表示。四位二进制数共有16种编码形式，由于十进制数只有0～9十个数码，故有六个码是多余的，放弃不用。而这种多余性便产生了多种不同的BCD码。在计算机中较常用的是8421 BCD码（在以后的章节中简称BCD码）。这种BCD码用四位二进制数表示一位十进制数的数码0～9，而这四位的权从高位到低位依次为8，4，2，1。十进制数0～15与8421 BCD码的编码关系见表1.6。\n\n```\n例如：(208)10＝(0010 0000 1000)8421 BCD\n　　　(1001 0001 0111 0101)8421 BCD＝(9175)10\n```\n\n### 字母与符号的编码\n\n- 在计算机里，字母和符号也必须用特定的二进制编码来表示。目前，在微机、通信设备和仪器仪表中广泛采用的是美国标准信息交换码ASCII（american standard code for information interchange）码。它用七位二进制码表示一个字母或符号，共能表示27＝128个不同的字符。其中包括数字0～9、英文26个大、小写字母、运算符、标点及其他的一些控制符号。常用的七位ASCII码见表1.7。\n\n例如：数字0的ASCII码为0110000B 或 30H\n　　　数字9的ASCII码为0111001B 或 39H\n　　　字母A的ASCII码为1000001B　或 41H\n\n- ASCII码多用于微型计算机的输入/输出设备（如电传打字机）及在数据传送过程中进行奇偶校验。\n",
        "category": "Other",
        "tag": [
            "计算机基础",
            "进制转换"
        ],
        "createdAt": "2015-11-20 17:24:48"
    },
    {
        "title": "实习“满月”工作感受",
        "author": "阿星Plus",
        "url": "2016-05-18-internship-month-summary",
        "markdown": "今天是2016年5月18日，时间过得真快，自上个月18号到今天来公司刚好一个月。这一个月的学习生活，让我学到了很多，不管是技术上还是生活阅历上都得到了很大的提升。\n\n在公司，和大家相处的都很融洽，大家一起吃饭，一起加班，一起讨论技术。在团队中，有高学历，有低学历，但是大家并不会因为学历的原因而疏远。刚进公司什么都不懂，慢慢的适应了现有的环境，每天上班下班加班，乐此不疲。\n\n祝经理，人很随性，对上班工作没有具体的硬性要求，弹性工作，正是我想要的。刚到公司的第一个星期，感觉很轻松，每天到点下班，有很多空余的时间，随着时间的推移，慢慢的有任务了，变得忙起来，每天要加班完成任务。正是这样，才让我得到了提升。从前端到后端再到测试，全接触。\n\n在我来“路博特”面试的时候，我已经收到其他公司的offer，之所以选择“路博特”，我主要从公司环境和公司氛围以及面试官来判定的。我当初既然选择了这里，我就会一如既往的在这里继续学习下去。我对公司的第一印象还是不错的，那么在这里不仅可以得到技能上的提升，还能收获身心的愉悦。\n\n说说这一个月在公司做的事情吧，其实也没什么，每天的工作日报都已经写得很详细了。第一，主要参与了一个教育局登记系统的项目，完成了几个JS的特效，充当了几次测试，熟悉了一下后天逻辑，完成了几个小的功能点。第二，一个公司自主二次开发的工作流平台，这个主要熟悉了一下流程，不做详解，接下来的重点既是这个。第三，学会若干技术点，比如iis安装部署等若干问题，文件的共享、访问，代码调试技巧等等。还有就是，一些非技术性技能，应该叫软技能吧！待人处事啊，处理工作中的问题啊，填写报销单啊之类的。\n\n最后就总结一下自己的不足和接下来的计划吧。工作上，有些许不足，不完美的地方。比如，在测试教育局登记系统的时候没有充分测试，有时候为了图速度，准确率不高。测试就是一个心细的活，像我这样可能会适得其反。还有比如JS效果的实现，在我本地是实现了，那么在服务器上了？在不同的浏览器上面呢？没有做好相应的兼容性，都是我的问题所在。\n\n接下来，我首先会完成公司安排下发的任务，在完成任务的同时，考虑更多的后果，不同的情况，做好相应的测试，确保万无一失。在自己完成任务的同时，学会帮助他人。因为帮助他人就是提升自己。还有就是按照自己的学习计划每天学习，不断进步。有不懂先自己研究，研究不出来问问同事。\n\n希望接下来的日子，能够共同成长进步！\n",
        "category": "Summary",
        "tag": [
            "工作总结",
            "实习",
            "总结"
        ],
        "createdAt": "2016-05-18 14:27:30"
    },
    {
        "title": "2016年终总结",
        "author": "阿星Plus",
        "url": "2017-01-04-2016-summary",
        "markdown": "### 一、工作总结\n\n2016年对我来说意义非凡，结束掉学生生涯正式步入职场，进入“路博特”，开始我的编码生活。这一年不仅学到了更多的专业知识同时也长了不少见识。从入职到现在已有八个多月的时间，在公司担任.Net研发一职。\n\n总的来说2016年实现了个人的预期目标，以下是2016年预期目标一览。\n\n1.2016年4月18日入职“武汉路博特工程科技有限公司”\n\n2.2016年6月熟练掌握三层架构开发网站\n\n3.2016年9月 .NET MVC 学习并入门\n\n4.2016年10月25日结束驾考生涯，驾驶证到手\n\n5.2016年11月可利用Entity Framework开发简单网站\n\n6.2016年12月对前端有了新的认识可开发自适应PC和手机屏幕的网页\n\n下面重点总结在公司开发过的网站以及参与过的项目。刚进公司主要是熟悉环境，了解行情，快速进行学习，适应公司的发展需要。最开始参与了一个教育局报名管理系统，负责了其部分JS特效及一些后台功能的实现。然后客串测试直至项目顺利上线。在这个小小的项目中，体会到了团队协同、效率、编码能力、测试等的至关重要。\n\n由于个人前端能力突出，紧接着便被安排编写设计院网站，在完成前端所有页面之后协同开发后台在短短不到一周的时间完成该项目。但是遗留下的问题却有很多，因为经验不足导致Bug众多。深深体会到维护一个项目远远比开发一个项目要难得多。从这个项目过渡，接下来的时间开发了至科网站、集团网站、路博特网站、至科检测人员资格查询系统前台、优仕德项目网站、江汉区交警大队网站、麦都教育网站等等公司一系列有关前台的页面。并且主导了域名的注册、备案、上线以及后期的维护工作。\n\n以上便是我2016入职以来的工作总结。\n\n### 二、自我评价\n\n#### 优点：\n\n1.环境适应能力强，能够很快适应新的工作环境\n\n2.具备团队合作意识，善于协调团队分工合作\n\n3.能够虚心接受他人的意见与建议，对符合的予以采纳\n\n4.各方面的知识都有涉猎，学习能力较快，接受新事物能力强\n\n5.能够在最短时间内完成Leader下发的任务，并自由合理分配时间\n\n6.在编程开发过程中，对项目有自己的见解以及问题解决方案\n\n#### 缺点：\n\n1.后半年积极度不高，比较懒散\n\n2.涉猎知识较多，但是都不精通\n\n3.个人能力和团队能力有限，不能更加完美的解决现有项目问题\n\n4.情绪化比较严重，不能合理控制自己的心情\n\n#### 对自己的要求：\n\n1.合理控制自己的时间\n\n2.在现有项目的基础上，完善不足之处\n\n3.学而知不足，专一研究DotNet技术，由此进行发散学习\n\n### 三、建议意见\n\n1.员工归属感需增强，实行奖惩制度，提高福利待遇\n\n2.希望公司可以大幅度提供住宿，家较远的员工可以给予公交补贴\n\n3.技术方面，向框架式开发渐进，框架开发速度快，效率高。急需一套属于公司内部的网站开发框架。\n",
        "category": "Summary",
        "tag": [
            "年终总结",
            "总结",
            "2016"
        ],
        "createdAt": "2017-01-04 01:59:56"
    },
    {
        "title": "我的实习记录",
        "author": "阿星Plus",
        "url": "2017-05-31-internship-summary",
        "markdown": "#### 2017年7月\n\n1、签订劳动合同，转正，实习期结束\n\n2、React-Native 学习研究\n\n#### 2017年6月19日星期一 — 2017年6月23日星期五\n\n1、重装系统/开发环境\n\n2、动态表单设计开发完成\n\n3、请假两天回武汉领毕业证、办理党员组织关系手续\n\n4、表单Bootstrap美化\n\n#### 2017年6月5日星期三 — 2017年6月9日星期五\n\n1、AC项目上线前的数据增量整理导出导入，Bug修改，业务功能刚改等\n\n2、动态报名表单实现 可创建表单，将创建的表单解析成html，根据创建的表单进行报名登记数据\n\n3、因公司内部原因，居家办公一周，6月15日恢复公司上班\n\n#### 2017年5月31日星期三 — 2017年6月2日星五\n\n1、动态表单研究\n\n2、微信编辑器修改出版\n\n3、AC项目需求更改，写业务代码\n\n#### 2017年5月22日星期一 — 2017年5月27日星期六\n\n1、仿活动行表单自定义设计器-简版\n\n2、AC项目遗漏问题解决\n\n3、服务器折腾、Hexo+Github折腾\n\n#### 2017年5月15日星期四 — 2017年5月19日星期五\n\n1、AC bug修复、需求更改 上线\n\n2、微信编辑器研究，demo\n\n3、自我学习\n\n#### 2017年4月29日星期六 — 2017年5月3日星期三休假\n\n#### 2017年5月4日星期四 — 2017年5月12日星期五\n\nAC汽车项目需求变更，第二版改版\n\n#### 2017年4月24日星期一 — 2017年4月28日星期五\n\n1、AC汽车项目bug修改\n\n2、WordPress数据导出、XML处理、导入数据至sqlserver\n\n3、AC汽车项目第一版完成，需求更改，确定需求，五一放假之后具体实施\n\n4、微信商城相关项目被打回，bug很多，功能没完成、重做重改\n\n#### 2017年4月17日星期一 — 2017年4月23日星期天\n\n1、AC汽车项目开发，我主要负责前台，由另一名同事负责后台\n\n2、终端连锁、EMBA、门店托管、产业研究院、论坛活动、盈利商家、咨询、调研、专栏、作者……\n\n3、19,20,21号晚上加班至9点+、22,23号周末全天加班完成全部开发工作\n\n4、终端连锁：按公司名称搜索、按公司首字母筛选搜索、首次加载10条信息，点击加载更多、详情内容页面\n\n5、门店托管：首次加载5条信息，点击加载更多、是否接手判断、详情内容页面\n\n6、论坛活动：首次加载5条信息，点击加载更多、内容详情页面、依据开始时间结束时间判断活动状态\\(已开始、已结束、还剩多少天开始\\)\n\n7、盈利商家：首次加载12条信息，点击加载更多、内容详情页面、合作状态、按类型分类搜索\n\n8、商家入驻、我要联系、我要报名、我要接手、我要合作、发布项目的表单提交\n\n9、调研，专栏，作者：依据现有项目进行二次修改，分类显示不同的页面，调研话题的显示、作者列表、属于作者的文章列表……\n\n9、banner轮播图，上一页，下一页、新浪腾讯微博分享、微信二维码、返回顶部、全站伪静态……\n\n10、耗时的功能点：json数据时间格式转换问题、时间的计算问题\\(临界值\\)、表单验证提示\\(SMValidator\\)、分类搜索功能\n\n#### 2017年4月5日星期三 — 2017年4月7日星期五请假回校答辩\n\n#### 2017年4月10日星期一 — 2017年4月14日星期五\n\n1、微信商城购买页调整，可在后台设置是否允许开发票，如果订单只含有不可开发票商品，\"我要发票\"不显示，增加前后收货地址、Email、后台收货地址修改功能，增加显示开发票的金额，购买前必须注册，如果商品为虚拟物品，详情页给出提示：\"本商品为虚拟商品，一经售出，概不退换。\"\n\n2、AC汽车项目需求更改，数据库创建，开发准备工作\n\n3、[当然我在瞎扯](http://api.xj8c.cc/articles)API接口开发\n\n#### 2017年3月27日星期一 — 2017年4月1日星期六\n\n1、微信商城虚拟物品交付邮件查收打开监控\n\n2、微信商城虚拟物品交付下载地址点击监控\n\n3、程序处理两张图片叠加在一起\n\n4、资讯站采埃孚ZF技术专栏信息展示\n\n5、新闻发布关键发布和定时发布为空验证检查\n\n6、AC汽车项目产品开发会议，需求讲解\n\n7、AC汽车项目开发计划表，4-5天，一个工作日完成\n\n8、AC汽车项目数据库 Table Schema、document created\n\n9、微信商城发送邮件切换至商用系统\\(Webpower\\)\n\n10、Web Service 使用学习、接口调用\n\n#### 2017年3月22日星期三 — 2017年3月24日星期五\n\n1、入职培训\n\n2、DotNetFrame框架搭建\n\n3、自己学习\n\n4、入职培训考试 - 92\n\n#### 2017年3月21日星期二\n\n1、文章关键词报表查询及导出\n\n2、GasgooNewsAuto 资讯站遗漏专题页\n\n#### 2017年3月20日星期一\n\n1、电脑中毒，系统重装\n\n2、微信商城项目首页样式更改，热门商品全部显示\n\n#### 2017年3月17日星期五\n\n1、资讯站发布新闻分类默认选中功能\n\n2、微信商城维护加载优化\n\n#### 2017年3月16日星期四\n\n自我学习看框架源码\n\n#### 2017年3月15日星期三\n\n1、索喜专题企业聚焦图片轮播\n\n2、文档转换\\(word，txt\\)为PDF\n\n#### 2017年3月14日星期二\n\n1、UEditor编辑器图片等比例缩放定制功能 √\n\n2、UEditor编辑器插入视频在线预览\n\n#### 2017年3月13日星期一\n\n1、ASP.NET MVC\n\n2、UEditor编辑器图片等比例缩放功能\n\n3、UEditor编辑器上传视频多终端显示\n\n#### 2017年3月10日星期五\n\n1、PC版快速专题 上下翻页状态修复 √\n\n2、商城项目图片处理、优化 √\n\n3、每周例会，项目汇报/ReactJS技术分享 √\n\n#### 2017年3月9日星期四\n\n1、PC版快速专题链接增加 √\n\n2、商城项目图片处理\n\n#### 2017年3月8日星期三\n\n1、PC版快速专题 √\n\n2、li多列图片上下页功能 jQuery分页插件jPages\n\n#### 2017年3月7日星期二\n\n1、资讯运营报表 √\n\n2、Vue.js\n\n3、PC版专题页\n\n#### 2017年3月6日星期一\n\n1、资讯站头尾部链接添加\n\n2、报表查询及导出\n\n#### 2017年3月3日星期五\n\n1、二维码的显示与隐藏\n\n2、本地加入图片随机展示\n\n3、会议项目汇报，微信小程序技术分享，每周例会主题技术分享\n\n4、Ueditor 上传图片等比例缩放\n\n#### 2017年3月2日星期四\n\n1、WEB API访问数据库，json接口 √\n\n2、.NET WEB API跨域方法配置 √\n\n3、ajax跨域解析，随机展示图片 √\n\n#### 2017年3月1日星期三\n\n1、原生js实现随机显示图片\n\n2、WEB API\n\n#### 2017年2月28日星期二\n\n1、提交实现发送邮件功能\n\n2、高峰论坛移动端专题 签入到SVN\n\n3、jQuery与javascript代码互转示例\n\n#### 2017年2月27日星期一\n\n1、正式入职上海盖世网络技术有限公司\n\n2、开发环境配置\n\n3、页面查看更多/收起功能\n\n#### 2017年2月10日星期五\n\n提辞职申请，项目整理，第一家实习公司生涯结束\n\n#### 2017年2月9日星期四\n\n原生js+css3实现下拉刷新效果\n\n#### 2017年2月8日星期三 - 请病假1天\n\n#### 2017年2月7日星期二\n\n自我学习，聚餐，简历更新，着手离职\n\n#### 2017年2月6日星期一\n\n1、开年第一天上班，例会\n\n2、电脑出问题，重装系统，配置开发环境\n\n3、同事离职，项目交接整理\n\n#### 2017年1月22日星期日\n\n最后一天上班，我要回家过年了\n\n#### 2017年1月21日星期六\n\n江汉区交通大队网站年前最终版本发布\n\n#### 2017年1月20日星期五\n\n前往总公司吃年饭领红包\n\n#### 2017年1月19日星期四\n\n江汉区交通大队网站页面修改、IE提示\n\n#### 2017年1月18日星期三\n\n江汉区交通大队网站线上测试、改Bug，外出部署项目\n\n#### 2017年1月17日星期二\n\n江汉区交通大队网站开发完成，数据填充，线上发布\n\n#### 2017年1月16日星期一\n\n江汉区交通大队网站用户签收通知、整合项目\n\n#### 2017年1月13日星期五\n\n江汉区交通大队网站后台每日值班、签收用户增删改查登录功能完成\n\n#### 2017年1月12日星期四\n\n江汉区交通大队网站后台三层框架、后台登录、签收弹窗、每日值班模块完成\n\n#### 2017年1月11日星期三\n\n江汉区交通大队第二版网站党建、新闻、政务、大队长信箱模块完成\n\n#### 2017年1月10日星期二\n\n1、麦都网站bug修改\n\n2、江汉区交通大队第二版网站首页完成\n\n#### 2017年1月9日星期一\n\n1、麦都网站bug修改\n\n2、网站维护\n\n#### 2017年1月6日星期五\n\n1、麦都网站前后台全部完成、发布线上测试\n\n2、至科cktit.com域名接入备案\n\n#### 2017年1月5日星期四\n\n1、麦都网站后台课程介绍模块全部完成\n\n2、URL重写实现前台伪静态化\n\n#### 2017年1月4日星期三\n\n1、麦都网站后台多层项目搭建，后台整体框架、登录模块、课程介绍\n\n2、购买域名cktit.com相关\n\n3、[2016年年终总结](http://www.jianshu.com/p/e709942f145c)\n\n4、至科人员检测资格查询系统后台二维码信息修改\n\n#### 2017年1月3日星期二\n\n麦都网站前端页面\\(自适应PC及手机\\)全部完成\n\n#### 2016年12月30日星期五\n\n麦都网站课程介绍、师资力量、考试资讯完成\n\n#### 2016年12月29日星期四\n\n麦都网站前台首页、关于我们完成\n\n#### 2016年12月28日星期三\n\n麦都网站前台首页 头部导航、轮播图、简介、讲师、课程介绍栏目\n\n#### 2016年12月27日星期二\n\n1、响应式导航\n\n2、麦都网站前台响应式布局解决方案\n\n3、Bootstrap栅格化布局\n\n#### 2016年12月26日星期一\n\n1、Sass CSS预处理器\n\n2、Linq...\n\n#### 2016年12月23日星期五\n\n1、Linq To SQL\n\n2、NoSql、MongoDB数据库基础\n\n#### 2016年12月22日星期四\n\n1、Google Code Prettify 代码高亮使用\n\n2、ASP.NET MVC5官方教程\\(中文版\\).pdf\\(看完\\)\n\n3、深入理解Bootstrap\n\n#### 2016年12月21日星期三\n\n1、ASP.NET MVC5\\(7层架构\\) 注册、登录、注销、修改密码功能实现\n\n2、Entity Framework6 Code First 相关\n\n#### 2016年12月20日星期二\n\nMVC5 && EF6\n\n#### 2016年12月19日星期一\n\n1、试验室信息管理系统修改意见、PPT\n\n2、ASP.NET MVC 实例学习\n\n#### 2016年12月16日星期五\n\n1、至科人员检测资格查询系统添加返回和打印按钮\n\n2、ASP.NET Razor语法\n\n#### 2016年12月15日星期四\n\n1、江汉区交警大队网站前台全部完成\n\n#### 2016年12月14日星期三\n\n1、江汉区交警大队网站旧版后台代码修改\n\n2、江汉区交警大队网站新版前台代码政务、服务、关于三个页面完成\n\n#### 2016年12月13日星期二\n\n江汉区交警大队网站前台代码首页和新闻页面完成\n\n#### 2016年12月12日星期一\n\n1、PDF《CSS揭秘》研读\n\n2、江汉区交警大队网站前台代码\n\n#### 2016年12月9日星期五\n\n1、Asp.Net 缓存、本地化和全球化、监控和诊断、单元测试、测试驱动开发TDD、配置与部署\n\n2、将博CMS\n\n3、HTTPS网站加密\n\n4、CSS三栏布局\n\n#### 2016年12月8日星期四\n\n1、江汉区交警大队网站功能修改\n\n2、[瞎JB扯](https://xj8c.cc)文章详情页面接入百度分享并支持https、自动获取文章内容添加到关键字及描述\n\n#### 2016年12月7日星期三\n\n1、前往武汉江汉区交警大队出差,项目部署,需求,改版方案...\n\n#### 2016年12月6日星期二\n\n1、江汉区交警大队网站每日值班功能完成\n\n2、留言功能实现\n\n3、首页漂浮窗\n\n#### 2016年12月5日星期一\n\n1、[至科](http://zktit.com/)网站导航修改兼容IE9+\n\n2、Entity Framework模式、ASP.NET MVC Ajax/分页/认证与授权\n\n#### 2016年12月2日星期五\n\n1、网站在线打包成App平台\n\n2、C\\#的匿名函数\n\n3、江汉区交警大队网站内容以及页面修改\n\n4、网站漂浮窗实现\n\n#### 2016年12月1日星期四\n\n1、C\\#的Attribute\n\n2、C\\#的预处理指令\n\n3、C\\#的反射机制\n\n4、C\\#的正则表达式\n\n#### 2016年11月30日星期三\n\n1、C\\#文件读写操作 IO\n\n2、C\\#委托 Delegate\n\n3、C\\#异常处理 ExceptionHandle\n\n4、C\\#事件处理机制 Event\n\n5、C\\#索引器 Indexer\n\n6、C\\#泛型 Generic\n\n7、ASP.NET MVC Introduce\n\n#### 2016年11月29日星期二\n\n1、Asp.Net MVC学习\n\n2、[武汉至科检测技术有限公司网站](http://zktit.com/)、[武汉东方建设集团建筑设计院网站](http://www.dfjssj.com/)、武汉至科检测技术有限公司论坛 3个网站功能清单整理\n\n#### 2016年11月28日星期一\n\n1、[喵呜网](http://meowv.com) 站点搬家\n\n1. 备份MySQL数据库\n2. 打包整个站点代码文件,通过FTP工具将其下载至本地\n3. 修改配置文件\n4. 上传至新服务器,导入MySQL数据库\n5. 解析IP地址,刷新本地DNS缓存\n6. 访问成功,搬家完成\n\n2、中电云集-云主机助手 工具\n\n3、Bootstrap Application\n\n4、CSS绝对底部方案\n\n#### 2016年11月25日星期五\n\n1、npm包管理工具\n\n2、Markdown语法\n\n#### 2016年11月24日星期四\n\n1、图片裁剪生成不同尺寸\n\n2、全屏背景轮播循环案例\n\n3、检测资格查询系统信息上传\n\n#### 2016年11月23日星期三\n\n1、SAE Sina\n\n2、C\\# ConsoleApplication 2048\n\n#### 2016年11月22日星期二\n\n1、HTML5\n\n2、至科网站导入报告、页面改写维护\n\n3、借助Flash完成图片批量上传\n\n#### 2016年11月21日星期一\n\n1、Github项目整理、静态资源上传\n\n2、Bolg更新\n\n3、前端插件学习以及整理\n\n#### 2016年11月18日星期五\n\n1、Layui 文档学习、Demo练习\n\n2、至科网站报告添加跟踪维护、技术指导\n\n3、本地在线学习/网校搭建\n\n#### 2016年11月17日星期四\n\n1、json序列化、反序列化\n\n2、在线搭建网校的方案\n\n3、JSHelper运用\n\n#### 2016年11月16日星期三\n\n1、Git命令学习\n\n2、网站Rewrite防盗链配置文件\n\n3、至科网站报告查询更新至线上\n\n4、本地网校平台搭建解决方案\n\n#### 2016年11月15日星期二\n\n1、自制html源码查看工具\n\n2、VUE.JS、Jquery文字提示插件\n\n3、Git命令学习\n\n4、看书jQuery开发从入门到精通\n\n#### 2016年11月14日星期一\n\n1、集团网站logo修改\n\n2、优仕德网站footer修改\n\n3、自适应全屏banner Demo\n\n#### 2016年11月11日星期五\n\n1、在线学习平台搭建解决方案\n\n2、武汉东方建设集团网站维护修改\n\n#### 2016年11月10日星期四\n\n1、Excel数据导入SQLServer完成\n\n2、报告查询码提取器小工具\n\n#### 2016年11月9日星期三\n\n1、HTML5 Canvas\n\n2、Excel数据导入SQLServer\n\n3、上传报告页面代码编写\n\n#### 2016年11月8日星期二\n\n1、Lims框架\n\n2、至科报告添加\n\n3、HTML5 localStorage 本地存储与读取\n\n4、有关二级域名的知识学习以及全站https加密处理等\n\n#### 2016年11月7日星期一\n\n1、七牛云存储SDK\n\n2、C\\#上传图片至七牛云\n\n#### 2016年11月4日星期五\n\n1、登陆页面重写、优化\n\n2、框架搭建\n\n#### 2016年11月3日星期四\n\n1、url重写研究,页面伪静态技术\n\n2、Vue.js学习\n\n#### 2016年11月2日星期三\n\n1、 Liger UI API\n\n2、代码发布，上传上线\n\n3、JS算法案例学习\n\n4、C\\#后台代码优化功能点实现\n\n#### 2016年11月1日星期二\n\n1、 Liger UI API\n\n2、NextEasy .net快速开发平台\n\n3、一般处理程序\n\n#### 2016年10月31日星期一\n\n1、 Liger UI框架搭建修改\n\n2、 Asp.net URL重写\n\n3、一般处理程序+html+ajax\n\n#### 2016年10月28日星期五\n\n1、jQuery Liger UI框架\n\n2、Bootstrap\n\n3、Webqic快速开发平台\n\n#### 2016年10月27日星期四\n\n1、jQuery学习、案例代码编写\n\n2、RoadFlow框架修改\n\n3、jQuery Liger UI API、Demo学习\n\n4、jQuery Liger UI框架搭建\n\n#### 2016年10月26日星期三\n\n1、权限管理框架申请及其查看\n\n2、Sina SAE\n\n3、.Net多图上传案例\n\n4、源码学习\n\n#### 2016年10月25日星期二—科目四考试\\(结束驾考生涯，驾驶证到手\\)\n\n#### 2016年10月24日星期一\n\n1、搭建在线慕课平台框架选择和方案的整理\n\n2、权限管理框架\n\n3、FineUI 通用权限管理框架（AppBoxPro）\n\n4、FuneUI ASP.NET 控件库 Demo\n\n#### 2016年10月21日星期五\n\n1、优仕德交互效果修改\n\n2、整合代码，转移至新服务器\n\n3、H+后台UI框架\n\n#### 2016年10月20日星期四\n\n1、后台UI\n\n2、Sina SAE\n\n3、优仕德项目\n\n4、jquery实例运用\n\n5、前端知识点总结\n\n#### 2016年10月19日星期三\n\n1、360等国产浏览器兼容性\n\n2、优仕德项目导航显示效果js修改、页面修改、搜索框百度搜索js\n\n3、githup学习\n\n#### 2016年10月18日星期二\n\n1、至科检测接入加密UKID登录\n\n2、Bug修改\n\n#### 2016年10月17日星期一\n\n1、至科检测工作流登录页面3种方案\n\n2、优仕德Bug修改\n\n#### 2016年10月14日星期五\n\n1、文件断点续传技术\n\n2、至科人员检测Bug修改、页面重写、兼容主流浏览器\n\n3、优仕德教育项目Bug修改、页面调整维护\n\n4、Hexo+GitHub学习研究\n\n5、IE不支持placeholder属性的解决方案研究\n\n6、Validator、jquery全选/反选 Demo\n\n#### 2016年10月13日星期四—考试科目三\n\n#### 2016年10月12日星期三\n\n1、优仕德项目招考信息列表详情页\n\n2、优仕德项目分页PageHelper\n\n#### 2016年10月11日星期二\n\n1、Html、css编码规范html页面编写\n\n2、Webservice\n\n3、Html全屏背景自适应效果demo\n\n4、优仕德项目后台详情页面\n\n#### 2016年10月10日星期一\n\n1、培训机构HTML代码 全部完成\n\n2、项目发布\n\n#### 2016年10月9日星期日\n\n培训机构HTML代码完成90%\n\n#### 2016年10月8日星期六\n\n1、发布至科监测类项目简报网站至服务器\n\n2、至科报告协助上传、维护\n\n3、培训机构HTML代码\n\n#### 2016年9月30日星期五\n\n1、微信公众号处理\n\n2、地图标注\n\n3、网页结构分析、代码编写\n\n#### 2016年9月29日星期四\n\n1、百度地图标注接入数据库、本地查询案例\n\n2、微信公众号\n\n3、至科网站维护小Bug修改\n\n#### 2016年9月28日星期三\n\n1、百度地图自定义标注研究\n\n2、结合数据库动态添加标注案例\n\n3、动态解析数组学习\n\n#### 2016年9月27日星期二\n\n1、地图标注研究以及案例\n\n2、至科报告查询代添加\n\n#### 2016年9月26日星期一\n\n1、至科微信公众号菜单添加\n\n2、后台UI框架\n\n#### 2016年9月23日星期五\n\n1、ASPOSE.WORD 操作Word Demo\n\n2、PHP基础语法学习\n\n3、微信公众号开发学习\n\n4、文档，文件，项目整理\n\n#### 2016年9月22日星期四\n\n1、WeX5 App 打包\n\n2、Oracle 基础学习\n\n3、.Net 奇淫巧技\n\n#### 2016年9月21日星期三\n\n1、WeX5 Baas.Net环境部署完成\n\n2、Base.Net后端开发学习\n\n3、研究微信公众号开发\n\n4、 微擎平台搭建学习\n\n#### 2016年9月20日星期二\n\n1、WeX5 hybrid APP开发学习\n\n2、WeX5 Baas.Net环境部署，需要VS2015最新版本\n\n3、本地应用打包学习、观看WeX5 在线学习文档\n\n4、2048 APP案例\n\n#### 2016年9月19日星期一\n\n1、WebAPP学习\n\n2、移动端框架jquery.mobil\n\n3、网站维护\n\n4、WebAPP 火车票查询案例\n\n#### 2016年9月18日星期日\n\n1、上线集团网站\n\n2、至科网站维护\n\n#### 2016年9月5日—2016年9月14日请假练车考试科目二\n\n#### 2016年9月2日星期五\n\n1、源码整理归档，数据库备份\n\n2、Asp.Net Mvc学习\n\n#### 2016年9月1日星期四\n\n1、Asp.Net MVC 学习\n\n2、电子宣传册在线制作\n\n#### 2016年8月31日星期三\n\n1、电子宣传册\n\n2、集团网站Bug修改、维护\n\n3、Entity Framework学习、EF三层搭建，增删改查案例\n\n#### 2016年8月30日星期二\n\n1、WebApp方案\n\n2、WeX5开源移动开发框架\n\n3、Entity Framework了解学习\n\n#### 2016年8月29日星期一\n\n1、电子宣传册\n\n2、网站维护\n\n3、ASP.NET MVC学习\n\n#### 2016年8月26日星期五\n\n1、Hadoop核心架构研究抄录\n\n2、C\\#语法糖\\(自动属性、隐式类型、匿名类型、Lambad表达式…\\)\n\n3、C\\#，T4模板学习\n\n#### 2016年8月25日星期四\n\n1、集团网站维护、时间修改\n\n2、至科网站维护、文字修改\n\n3、电子宣传册\n\n#### 2016年8月24日星期三\n\n1、检测单位上岗人员检测资格查询系统完善\n\n2、Node.js\n\n3、集团网站新闻时间修改、维护\n\n#### 2016年8月23日星期二\n\n1、继续集团网站备案\n\n2、QR-Code二维码生成\n\n3、至科检测资格信息管理系统\n\n4、工作室网站美化调整\n\n#### 2016年8月22日星期一\n\n1、至科网站导航检测报告真伪查询修改\n\n2、检测人员资格查询后台界面修改调整\n\n3、短信验证提交容联审核通过，根据审核通过模板Id修改短信验证，现都可查询\n\n4、添加无验证查询页面用于二维码扫描查询\n\n5、集团网站接入阿里云备案\n\n#### 2016年8月19日星期五\n\n1、集团网站、设计院网站、至科网站维护\n\n2、至科检测人员资格信息管理系统\n\n3、.Net Ajax应用与学习\n\n#### 2016年8月18日星期四\n\n1、设计院网站Bug修改，信息替换，导航调整，招聘英才列表显示调整\n\n2、至科网站Bug修改，热点检测项目滚动特效，图片修改，添加试验室信息管理系统链接，查询系统下报告查询添加验证码限制查询功能\n\n3、至科检测人员资格信息管理系统页面修改，增加图片验证码限制功能\n\n#### 2016年8月17日星期三\n\n1、至科人员资格查询系统上线\n\n2、至科、设计院、路博特网站更新需求、Bug修改\n\n3、至科、设计院网站后台增加上传新闻图片功能\n\n4、极验验证码\n\n#### 2016年8月16日星期二\n\n1、至科检测资格信息查询系统本地发布进行后台测试\n\n2、检测资格查询系统Bug修改\n\n3、H5 & CSS3 实战书看完\n\n#### 2016年8月15日星期一\n\n1、至科检测资格信息查询系统静态页面完成\n\n2、表单验证js完成\n\n3、后台用户查询登录三层代码完成\n\n4、登录页面保存用户信息至数据库完成\n\n5、手机验证码发送并校验完成\n\n6、点击弹窗显示和关闭\n\n7、修改路博特页面文字错误\n\n8、美化至科检测资格信息查询系统后台\n\n9、至科检测资格信息查询系统前后台完成，可接入容联短信平台进入测试阶段\n\n#### 2016年8月12日星期五\n\n1、学习node.js\n\n2、至科、集团、路博特网站代码修改整理\n\n3、转达任务至团队人员，转发邮件\n\n4、上传代码，上线网站\n\n5、至科资格检测信息管理系统对接\n\n#### 2016年8月8日—2016年8月11日请假回家休息\n\n#### 第十六周总结\n\n本周完成工作\n\n1.集团网站Bug修改\n\n2.路博特网站框架、数据库搭建\n\n3.三层代码以及解决方案模块\n\n4.容联短信验证接口代码实现、文档说明\n\n5.各个版本代码整理、备份管理...\n\n本周工作总结\n\n本周主要完成了集团网站的Bug修改，经过测试之手，网站存在很多Bug，都是在开发过程中疏忽的。软件测试这个环节在软件行业中是至关重要的，很多人认为软件开发中贡献最大的人是开发人员，这个观点不能否认，但是软件测试人员也扮演着非常重要的角色。经此次开发过程遇到的一些问题，学到了不少经验。在填充数据的时候遇到一个SQL错误，.Net SqlClient Data Provider，经过查阅资料，分析原因，最后得以解决并且进行记录\\(SQL错误：.Net SqlClient Data Provider\\)...\n\n下周工作计划\n\n下周请假，回家好好休息，上班后好好工作。\n\n#### 2016年8月5日星期五\n\n1.集团网站后台公益事业、活动剪辑详情页面\n\n2.容联短信验证接口代码实现、文档说明\n\n3.事业单位等培训机构网站\n\n4.路博特网站交接、后台页面图标logo、链接更换\n\n5.集团网站Bug修改完毕\n\n6.至科、集团网站源码发送\n\n#### 2016年8月4日星期四\n\n1.容联短信接口文档学习\n\n2.Demo,暂时只可以实现接收收短信，未进行验证。\n\n2.集团网站Bug修改\n\n#### 2016年8月3日星期三\n\n1.集团网站Bug修改\n\n2.Lbt网站3层代码完成\n\n3.后台解决方案模块完成\n\n#### 2016年8月2日星期二\n\n1、集团网站Bug修改\n\n2、Lbt网站简介模块完成\n\n3、各种琐事…\n\n#### 2016年8月1日星期一\n\n1、集团网站完成\n\n2、上传Lims管理系统\n\n3、Lucene.Net+盘古分词学习\n\n4、Lbt数据库\n\n5、Model代码\n\n#### 第十五周总结\n\n本周完成工作\n\n1.集团网站后台功能已全部实现\n\n2.前台数据绑定完成90%左右\n\n本周工作总结\n\n集团网站从前台到后台，收获颇多。\n\n本周开始着手写集团网站后台代码，因为是自己写的前台页面，所以对整个页面的架构是一目了然的。\n\n首先根据前台页面创建了网站数据库。让后利用代码生成器生成网站Model层代码，对于代码生成的好处就是可以减轻工作量，因为网站涉及到30来个数据表，如果是手写Model层代码会耗费大量的时间。\n\n根据生成的Model层代码手写Dal与Bll层增删改查的代码。这个耗费了我大量的时间。可以说在三成架构中，网站的Dal层其实就是网站的灵魂，所有的增删改查分页查询等等都离不开Dal层。\n\n分页用的存储过程，存储过程的好处有很多，运行速度快，可以接收参数、输出参数、返回单个值或者多个结果集以及返回值。这样网站相对来说会比较稳定。\n\n然后在后台开发中，用到了多图上传，因为之前没有做过，便在网上学习了一下多图上传的案例，总的来说我有两种解决方案，一种是多图上传的插件，这个比较强大，学习了一下弄懂了其原理，另外一种便是循环上传图片，因为多图上传还是需要一张一张的上传，这个比较简单，由于时间和效率的原因，我采用了循环上传。\n\n最后一个便是缩略图生成，这个在网上找的现成的生成缩略图的一个方法，看了一下代码，可以高按照度或者宽度的比例来生成对应的缩略图，而且也不会对图片造成变形。直接调用，在前台资质资格、集团荣誉、领导关怀三个模块用上了。\n\n一个工作日的时间，完成了集团网站后台所用逻辑代码，以及前台90%的数据绑定。\n\n下周工作计划\n\n1.网站数据添加完毕\n\n2.交由测试人员进行测试\n\n3.配合测试人员进行Bug修改\n\n4.完善手头上的工作，休假一星期\n\n#### 2016年7月29日星期五\n\n1.工程业绩模块\n\n① 竣工工程 - 增删改查、分页列表、分类查询、前台数据绑定\n\n② 在建工程 - 增删改查、分页列表、分类查询、前台数据绑定\n\n③ 设计工程 - 增删改查、分页列表、前台数据绑定\n\n2.企业文化模块\n\n① 公益事业 - 增删改查、多图上传、前台数据绑定、轮播显示\n\n② 活动剪辑 - 增删改查、多图上传、前台数据绑定、轮播显示\n\n3.联系我们 - 全部完成\n\n4.友情链接 - 全部完成\n\n5.后台首页 - 文字更换、logo修改、页面修改美化优化\n\n6.后台修改密码功能完成\n\n7.后台整体页面搭建完成\n\n8.前台数据绑定完成\n\n#### 2016年7月28日星期四\n\n1.集团网站工程业绩模块\n\n① 竣工工程后台增删改查，图片上传，列表显示，分类查询\n\n② 在建工程后台增删改查，图片上传，列表显示，分类查询\n\n③ 设计工程后台增删改查，图片上传，列表显示\n\n2.集团网站企业文化模块\n\n① 公益事业后台增删改查，多图上传并显示\n\n② 活动剪辑页面添加完成\n\n#### 2016年7月27日星期三\n\n1.集团网站联系我们模块\n\n① 在线留言完成\n\n② 联系方式\\(站点信息\\)完成\n\n2.友情链接前台数据绑定\n\n3.学习多图上传，实时预览代码\n\n#### 2016年7月26日星期二\n\n1.友情链接模块增删改查\n\n2.企业文化模块\n\n① 企业理念Update\n\n② 党团建设增删改查\n\n3.人力资源模块\n\n① 简历投递上传下载\n\n② 学习平台增删改查\n\n4.联系我们页面搭建完毕\n\n#### 2016年7月25日星期一\n\n一、集团网站\n\n1.新闻中心模块\n\n添加、后台列表展示、删除、分页查询、分类型查询完成\n\n2.科技创新模块\n\n① 技术中心、科研领域修改功能完成\n\n② 科技成果添加、后台展示、删除、分页查询、分类型查询完成\n\n3.人力资源模块\n\n① 人才战略修改功能完成\n\n② 人才聚集添加、后台带缩略图展示、删除、分页查询完成\n\n③ 人才招聘添加、后台展示、删除、分页查询完成\n\n二、至科网站\n\n1.整理上线所缺数据文档\n\n2.修改至科网站Logo及导航菜单颜色\n\n三、路博特网站\n\n1.路博特主机域名绑定\n\n2.上线路博特静态页面网站\n\n#### 第十四周总结\n\n本周完成工作\n\n1.至科网站上线工作\\(代码整理、数据填充...\\)完成\n\n2.路博特网站所有HTML静态页面完成\n\n3.路博特网站后台数据库搭建完成\n\n4.路博特网站后台3层框架代码搭建完成\n\n5.[路博特](http://www.lubok.cn) 网站域名备案成功\n\n6.集团网站所有HTML静态页面完成\n\n7.集团网站项目计划流程图\n\n8.集团网站后台数据库搭建完成\n\n9.集团网站后台登录模块、关于集团模块完成\n\n本周工作总结\n\n本周在三个网站之间来回切换，至科网站上线工作完成，只差备案成功，上传代码，算是告一段落。\n\n公司内部网站改版，独立完成了PC版及手机自适应版静态页面路博特网站，一并完成后台数据库的搭建及网站3层框架的搭建。\n\n主要时间还是花在集团网站上，集团网站页面众多，虽说有部分重复页面，但是也还是达到了36个页面。花费了我很多时间来完成，美工多次外出办公回来传达需求，修修改改终于在周四完成了所有页面，然后马不停蹄创建数据库，搭建后台框架进行项目计划安排分析。现已经完成登录模块、关于集团模块的后台代码。\n\n下周工作计划\n\n1.全身心投入到集团网站后台开发当中去，按计划表进行开发，在周末之前完成所有后台逻辑代码\n\n2.配合完成至科网站上线及备案工作...\n\n#### 2016年7月22日星期五\n\n集团网站后台\n\n1、Model层所有代码完成\n\n2、登录模块完成\n\n关于集团模块\n\n1、集团简介、董事长致辞、组织结构三大模块Update完成\n\n2、资格资质、集团荣誉、领导关怀，标题，多图上传，列表展示，存储过程分页查询完成\n\n新闻中心模块—新闻中心模块界面搭建完成，数据访问层\\(Dal\\)代码完成\n\n#### 2016年7月21日星期四\n\n1、Lbt网站数据库搭建完毕\n\n2、Lbt网站三层框架搭建\n\n3、集团网站项目计划图\n\n4、集团网站数据库搭建完毕\n\n5、集团网站三层框架搭建\n\n6、集团网站后台页面框架搭建\n\n#### 2016年7月20日星期三\n\n1、集团网站静态页面全部完成\n\n① 领导关怀页面完成\n\n② 技术中心页面完成\n\n③ 活动剪辑详情页完成\n\n④ 公益事业、公益事业详情页完成\n\n⑤ 科研领域完成\n\n⑥ 简历投递完成\n\n⑦ 学习平台、学习平台详情页完成\n\n2、集团网站后台数据库搭建\n\n#### 2016年7月19日星期二\n\n1、集团网站修改添加页面\n\n① 工法标准改为工法，增加技术规章类型\n\n② 水利建设工程改为园林绿化\n\n③ 工程业绩模块增加设计工程页面\n\n④ 工地整理工程改为土地整理工程\n\n⑤ 后台数据库搭建\n\n2、[路博特](http://www.lubok.cn) 网站域名备案成功，新增[设计院](http://dfjssj.com) 网站打印核验单初审通过，待邮寄核验单。\n\n#### 2016年7月18日星期一\n\n1、至科网站上线数据填充\n\n2、集团网站页面添加和修改\n\n3、分配至科网站数据填充任务给ZouXueXia\n\n4、jquery插件学习及使用\n\n#### 第十三周总结\n\n本周有事请假了一天，首先这一周完成了路博特静态网站，PC版和手机版自适应页面\n\n路博特网站备案告一段落，静等管局审核完成\n\n着手至科网站上线任务，修改了至科网站的一些bug和新增了一些功能\\(登录UKID验证\\)\n\n集团为网站因需求而进行修改压面，添加页面\n\n计划下周将至科网站上线全部完成，开始集团网站前后台和路博特网站后台代码编写\n\n#### 2016年7月15日星期五\n\n请假一天...\n\n#### 2016年7月14日星期四\n\n1、完善路博特网站页面\n\n2、路博特数据库搭建\n\n3、至科网站：新闻中心-至科空间模块完成\n\n4、至科网站：服务项目模块修订整改\n\n5、后台测试数据删除，数据库测试数据清空\n\n6、整合至科网站源码、部署版代码，随时可以上线\n\n7、集团网站：人力资源-添加人才聚集模块、首页-banner图更换...\n\n#### 2016年7月13日星期三\n\n1、路博特网站静态页面全部完成\n\n2、至科网站页面信息修改\n\n3、至科后台登录加入UKID数据验证\n\n4、最新版至科网站发布与上传\n\n#### 2016年7月12日星期二\n\n路博特网站\n\n首页、走进路博特、解决方案、解决方案详情页、新闻资讯、加入我们、联系我们-页面完成\n\n新闻资讯详情页，无样式模板\n\n产品与解决方案公用一个页面。暂时没有多余的项目，建议导航目前只放一个解决方案，产品保留，需要的时候可以加上。\n\n#### 2016年7月11日星期一\n\n1、提交备案信息\\(管局审核中\\)，等待审核结果\n\n2、学习Node.js\n\n3、整理有关OA、CRM、ERP...解决方案的展示文字\n\n4、整理路博特网站相关资料\n\n#### 第十二周总结\n\n这周完成了公司集团网站的所有静态页面，这是我在公司做的第三个项目了。感觉好累，现在有点力不从心，没有刚开始的激情了。\n\n大夏天，好友同学们都回家避暑去了，然而我已经很早就没有暑假可言了。\n\n马上出来实习就三个月了，好想回家，从过年到现在都没有回过家，想回去看看。\n\n#### 2016年7月8日星期五\n\n1、教育局Js代码加密\n\n2、Node.js学习\n\n3、集团网站导航修改\n\n#### 2016年7月7日星期四\n\n1、打印网站备案核验单\n\n2、修改集团网站静态页面\n\n① 工程业绩模块：竣工工程、在建工程修改为图文展示样式\n\n② 工程业绩详情页\n\n3、网站所有信息及联系方式修改\n\n4、数据库：\\(用户、新闻中心、新闻类型、工程业绩、业绩类型、联系我们-在线留言、联系我们-联系方式）表创建\n\n#### 2016年7月6日星期三\n\n湖北武汉，暴雨，休息一天\n\n#### 2016年7月5日星期二\n\n1、集团网站静态页面全部完成\n\n2、放弃之前路博特域名，进行新网站备案\n\n3、网站备案，核减单待打印上传\n\n4、集团网站需修改部分信息\n\n#### 2016年7月4日星期一\n\n1、集团网站 - html页面\n\n① 新闻中心模块完成\n\n② 科技创新模块完成\n\n③ 人力资源模块完成\n\n④ 企业文化模块完成\n\n⑤ 联系我们模块完成\n\n2、集团网站页面美化\n\n#### 第十一周总结\n\n本月工作内容\n\n1、设计院网站\n\n2、至科网站\n\n3、集团网站\n\n4、路博特网站\n\n5、有关域名备案等相关工作\n\n本月工作总结\n\n1、设计院网站两个版本的前台页面\n\n2、分工合作，完成设计院数据库设计，后台代码编写\n\n3、至科网站前台页面\n\n4、至科网站后台代码编写\n\n5、经测试修改两个网站存在的Bug，达到可以上线的版本\n\n6、正在进行集团网站前台页面的代码编写\n\n7、域名备案等工作\n\n8、工作需求中的自我学习\\(Asp.Net存储过程、JS各种动画效果、H5+CSS3全新前端代码、寻找论坛BBS源码、Asp.Net富文本框使用案例\\)\n\n下月工作计划\n\n1、集团网站前端页面\n\n2、集团网站后台代码\n\n3、路博特网站前端页面\n\n4、路博特网站后台代码\n\n5、工作中的其它任务\n\n6、自我学习\n\n4月份来公司，至今也已两个多月了。\n\n马上就是3个月了，学到了很多，也领悟了很多。\n\n7月份想要请假休息几天回家一趟，感觉有点疲惫。\n\n#### 2016年7月1日星期五\n\n1、集团网站首页全部完成\n\n2、关于集团模块\\(集团简介、董事长致辞、组织结构、资质资格、集团荣誉、领导关怀页面\\)完成\n\n3、工程业绩页面\\(竣工工程模块\\)\n\n4、提交工信部域名注销备案申请\n\n#### 2016年6月30日星期四\n\n1、集团网站首页\n\n2、域名注册证书\n\n#### 2016年6月29日星期三\n\n1、跟进花生壳域名过户，填写过户原因\n\n2、修改至科网站导航样式、联系我们页面\n\n3、JS速度动画、透明度动画、缓冲动画、多物体动画、链式动画、同事运动案例，万能运动框架编写\n\n4、集团网站首页代码编写\n\n#### 2016年6月28日星期二\n\n1、联系花生壳办理域名过户...\n\n2、查看，对比后，提供企业邮箱的两种方案\n\n3、寻找Asp.Net版BBS源码\n\n#### 2016年6月27日星期一\n\n1、修改设计院和至科两个网站的bug\n\n2、JS划入划出特效学习\n\n#### 第十周总结\n\n本周完成工作\n\n1、两个网站的bug修改\n\n2、至科网站的后台编码，前台数据绑定，功能模块全部完成\n\n3、提交了设计院网站的最终版本\n\n4、报告查询模块查询报告\n\n5、整合了至科网站最终版本含源码版和部署版\n\n本周达到了预期结果：\n\n1、设计院的网站告一段落，全部完成\n\n2、至科网站前后台全部完成，经测试修改整合也已完成改版\n\n正在进行中的事情：\n\n1、路博特网站\n\n2、[集团网站](http://www.whdfjs.com/)\n\n下周工作计划\n\n1、编写集团网站静态页面\n\n2、后台管理系统\n\n3、路博特网站\n\n#### 2016年6月24日星期五\n\n1、安排今日任务\n\n① ChenXia：集团网站设计、以第一版为主\n\n② ZouXueXia：设计院网站和至科网站总体测试\n\n③ PengYun：路博特网站前台/后台\\(从后台开始\\)\n\n④ MySelf：集团网站前台页面HTML代码，跟进设计，提出建议，修改方案\n\n2、分享完整的富文本框编辑器Demo\n\n3、整理总结文件上传与下载的功能知识点\n\n4、整合至科网站最终版本含源码版和部署版\n\n5、Web前端css工作流，代码技巧，语法糖学习\n\n6、集团网站首页头部logo、右侧搜索、导航栏\n\n#### 2016年6月23日星期四\n\n1、修改至科测试所提交的Bug\n\n2、发布最新版本提供测试人员进行反测\n\n3、反测bug修改，测试完成，发布服务器，至科网站到达一个节点\n\n4、修复文件下载模块，文件下载无法打开问题。\n\n#### 2016年6月22日星期三\n\n1、协助网站备案，邮寄核验单\n\n2、整合设计院网站最终版本含源码版和部署版\n\n3、修改至科网站测试所存在的bug\n\n4、更改至科网站所有时间统一为年月日形式\n\n5、报告查询中修改报告信息时显示所有信息\n\n6、报告查询添加日志管理模块，协同完成\n\n#### 2016年6月21日星期二\n\n1、报告查询之增加查询码功能模块\n\n① 增加查询码字段，修改3层数据\n\n② 完成带有查询码功能的增删改查\n\n③ 依据报告编号使用不可逆算法MD5加密截取其中5位字符串保存至数据库\n\n④ 前台报告查询功能初步实现\n\n2、至科网站整体调试修改，总体功能需求全部实现\n\n3、部署至科网站提交给测试人员进行测试\n\n4、设计院网站域名备案信息等若干问题\n\n#### 2016年6月20日星期一\n\n1、申诉路博特域名账号密码相关信息，找出问题所在\n\n2、联系花生壳官方客服，找到修改账号密码解决办法\n\n3、至科网站任务规划\n\n4、至科网站后台报告查询模块增删改查\n\n5、至科网站前后报告查询模块查询功能\n\n① 依据报告编号精确查询\n\n② 为空提示\n\n③ 不存在给出提示\n\n④ 正确显示查询信息\n\n⑤ 依据后台填写报告内容，填多少信息，查出来就是多少信息\n\n6、接收路博特设计网页设计方案，分析效果，实现难度，不合理之处...\n\n7、至科后台部分修改\n\n① 友情链接模块修改\n\n② 所有页面防止不登录直接访问\n\n#### 第九周总结\n\n写总结，坚持的也有两个月了，收货颇多。\n\n这周同学聚餐了，喝的酩酊大醉，还记得大一那会，懵懵懂懂，一转眼大学都已经快要结束了。\n\n这周写了美工设计的所有psd页面，写完前端继续协助做后端。改了测试给的上个网站的bug。希望在下周完结手头上的所有事。因为报考了驾校一直没时间去练车，准备在忙完手上的项目请假一个星期回学校去练车，一直拖下去也不是办法。\n\n今天父亲节，突然想家了，半年多了还没回去过，等待下一个小长假，我想回家看看。\n\n...不想写了，烦！\n\n#### 2016年6月17日星期五\n\n1、至科网站页面修改，添加新功能\n\n2、后台主页添加时钟\n\n3、修改密码功能\n\n4、后台查询报告模块\n\n5、动态添加检测参数信息\n\n6、查询报告模块添加功能\n\n7、至科待办事项分配\n\n#### 2016年6月16日星期四\n\n1、查看提交的测试缺陷报告\n\n2、分析缺陷报告中的bug\n\n3、修改设计院网站bug及规避bug\n\n4、合并整合至科网站代码\n\n5、报告查询页面\n\n6、报告查询表数据库设计\n\n7、数据字典整理\n\n8、至科后台图片替换，页面添加修改美化\n\n#### 2016年6月15日星期三\n\n1、装系统\n\n2、搭建论坛\n\n3、创建设计院网站下载中心、友情链接两个表\n\n4、根据需求手写model、dal、bll三层代码\n\n5、完成后台下载中心之上传文件功能\n\n6、后台下载中心文件管理功能\n\n7、文件信息列表分页、删除功能\n\n8、前台所有页面转换为aspx页面\n\n#### 2016年6月14日星期二\n\n1、人力资源模块完成\n\n2、联系我们模块完成\n\n3、添加禁止选中页面内容脚本\\(可选\\)\n\n4、添加禁止鼠标右键脚本\\(可选\\)\n\n5、至科页面全部实现完成\n\n6、至科页面思维导向图\n\n7、服务器中配置MVC项目\n\n8、和PengYun交流后台页面搭建及代码实现\n\n9、至科后台代码，文件上传与下载Demo\n\n#### 2016年6月13日星期一\n\n1、修复设计院网站bug\n\n2、至科网站\n\n1.关于至科模块，公司简介、荣誉资质、试验室、工程业绩4个页面完成\n\n① 图片瀑布流布局\n\n② 图片大图弹窗浏览\n\n2.服务项目模块，地基基础工程检测、建筑幕墙工程检测、钢结构工程检测、主体结构检测、节能检测、工程设备检测6大页面完成\n\n3.下载中心模块，委托单下载、规范下载2个页面完成\n\n4.新闻中心模块，公司新闻、行业新闻、新闻详情3个页面完成\n\n5.整个网站禁止复制内容\n\n#### 第八周总结\n\n刚刚过完端午，相信大家都有吃粽子吧，呃...反正我没吃。\n\n这一周，总感觉是上一周，可能是玩了三天，糊涂了，这一周完成了一个项目。\n\n整个项目的一大半由我一人完成，其中包括：前台静态页面，利用HTML5+CSS+JavaScript编写、提供一套后台UI、后台6\\) 三层框架搭建、整体优化布局、登录模块、新闻资讯、招聘英才、数据库三个表的设计。。。\n\n今天周日，因为放了三天假，所以今天正常上班，又接手了一个新的项目，和上一个项目类似，可又不类似，总之是多了很多细节，看似简单的页面，却要调试很久。各种特效，用户交互效果也很多。写了一天多一共写了三个页面，第三个页面还没有完全完成。有点吃不消了，作为一共.Net开发，却被公司用来写前端页面，写完前端页面又要继续跟踪后台代码。。。一个网站十几个页面，全由我一个人完成，没日没夜的写。\n\n是不是应该和经理提出...嗯，我需要一个助手，页面太多了吃不消。希望有人能帮我分担一下。这样我也不用那么累。是吧？\n\n#### 2016年6月12日星期日\n\n1、至科网站 – 首页\n\n① 首页总体代码完成\n\n② 至科集团简介、热点检测项目、新闻资讯三大小模块完成\n\n③ 底部二维码/公司信息/友链\n\n2、关于至科/公司简介页面完成\n\n3、荣誉资质页面 – 难点\n\n4、查看设计院网站测试bug并修改\n\n5、和PengYun对接至科网站后台功能\n\n6、对至科网站图片内容、大小提出疑问并让美工修改\n\n#### 2016年6月9日星期四 - 2016年6月11日星期六 - 端午节放假\n\n#### 2016年6月8日星期三\n\n1、修改设计院网站遗留Bug\n\n① 后台上传图片给出建议像素提示\n\n② 服务项目模块每页显示12条数据\n\n③ 修改翻页无效问题\n\n④ 修复上传图片重名的弊端\n\n2、至科网站 – 首页\n\n① 首页总体设计\n\n② 头部加入收藏JS效果\n\n③ 炫酷3D导航栏\n\n④ 首页banner图轮播\n\n⑤ 首页内容区布局\n\n#### 2016年6月7日星期二\n\n1、整合设计院网站\n\n2、开发文档编写\n\n3、设计院后台图片处理\n\n4、所有代码整理，美化\n\n5、至科网页样式交涉分析\n\n#### 2016年6月6日星期一\n\n1、设计院网站\n\n2、修改密码功能\n\n3、后台页面修改\n\n4、快捷编辑\n\n5、存储过程分页\n\n#### 第七周总结\n\n七七四十九了。本周接手了公司的一个项目，相对来说比较忙，今天还加了一整天班。\n\n这一周完成了美工所设计的第二版设计院PSD，整整十几个页面加部分JS特效，修修补补总算完成。然后写完页面继续跟着做后台。截至周日，我所负责的两个模块，新闻信息发布和招聘英才后台增删改查，前台显示，分页查询等等已圆满完成。\n\n期间，遇到好几个坑，然后又自己填坑，所有数据访问都是自己手写，以往都是添加和显示在不同的页面，这一次这个后台添加和显示在同一个页面，是一个Tab切换效果。涉及到修改传值到添加那里显示出来。久久不能解决，最后静下心来想了想解决方案，然后成功解决。\n\n然后就是利用了存储过程，写了一个数字分页查询。现在，对于我来说，一个项目的增删改查已经不是问题了。从前台到后台，都能信手拈来，这种感觉很好。不过还是有些不足，很多技术还是不会，希望能继续接触一些前沿的技术，达到.net行业的标准。今天很累，在公司写了一天代码。天气热加上上火，真是难受。\n\n就先总结到这里吧，2016年6月5日22:33分。\n\n#### 2016年6月3日星期五\n\n设计院网站第二版终结\n\n学习网页相关知识\n\n设计院后台招聘信息模块\n\n#### 2016年6月2日星期四\n\n设计院网站设计\n\n#### 2016年6月1日星期三\n\n1、设计院网站\n\n2、近期工作总结\n\n3、开会内容\n\n① 教育局项目\n\n② Lims项目\n\n③ OA\n\n④ 设计院网站\n\n⑤ 手提袋\n\n⑥ 至科网站改版升级\\(报告查询\\)\n\n⑦ Lbt网站改版升级\n\n#### 2016年5月31日星期二\n\n1、设计院网站数据库\n\n2、设计院网站页面\n\n3、设计院网站后台\n\n#### 2016年5月30日星期一\n\n1、SQL架构+数据导入导出\n\n2、学习JS解析json\n\n3、C\\#.Net解析json\n\n4、响应式Web设计 HTML5和CSS3实战\n\n5、H5全新语义化元素整理总结\n\n#### 第六周总结\n\n这周过得比较快，只上了三天班，请假了两天。周一完成了设计院网站的第一个html版本，周二周三回学校去了。\n\n转眼间，马上就要毕业了。回学校照了个毕业照，然后毕业证头像采集，让室友陪我打了几把LOL，哈哈，原来我是真的很坑。\n\n这周接触了一个新的UI，FineUI。基于 jQuery / ExtJS 的 ASP.NET 一个控件库，由来自中国的程序员 三生石上 和 RingoDing 创建并维护。在博客园中看到的，然后一路跟随到FineUI官网，并瞅了瞅，感觉还不错。利用其拖拖拽拽就完成了一个demo。不过好归好，在其华丽的背后总有那么些不足之处，这还是服务器端控件，严重的拖慢了网页加载速度，而且异常的臃肿。就不与其它UI作比较了，毕竟各有各的优势。\n\n嗯，还有就是我在腾讯云买了一个服务器。最低配置的那种，不过对我来说可以用了。我将自己做过的项目都挂上去了，拿来测试、瞎折腾还是可以的。\n\n马上第七周了，这一周应该会很忙，设计院的网站开始做了，框架已经搭建好，只等数据库设计完成了。然后我还要更改网站样式，因为第一版略显丑态，不太合适，美工又重新设计了新的样式。黑暗的世界马上来临。\n\n#### 2016年5月27日星期五\n\n1、搭建设计院后台3+层框架\n\n2、数据库搭建分析\n\n3、后台UI修改\n\n4、折腾服务器，将自己的项目上传至服务器\n\n#### 2016年5月26日星期四\n\n1、分析设计院网页实现方法\n\n2、学习FineUI\n\n3、利用FineUI完成登录Demo\n\n#### 2016年5月25日星期三\n\n上午毕业证头像采集，下午照了毕业照\n\n#### 2016年5月24日星期二\n\n请假的第一天，今天返校了\n\n#### 2016年5月23日星期一\n\n1、完成设计院网站的设计\n\n2、响应式Web设计学习\n\n3、看书《H5和CSS3实战》\n\n#### 第五周总结\n\n第五周了，公司走了个同事，是我在第一周总结中提到的一个学长。在之前，他就跟我说过，他干不长，不喜欢公司的这种模式，他认为学不到东西。所以他告诉我，他忍不住了，要辞职了。两个字，呵呵~\n\n这周，感觉过得蛮快，周一跟经理一起出去了一趟，早早地起了床，真正体验到了一把，客户就是上帝。对，没错，我们去见客户了，本来是去部署项目的，可是，压根不是我想的那样，被打回来了，客户的随便一句话，可能在他认为就一个小小的东西，我们都要修改半天。…后来还好，虽然还有不少问题，但是第二天如期上线了。\n\n不知不觉，已经到五月下旬了，来这个公司是4月18号到今天也有一个月零4天了。差不多什么也都摸清楚了，鉴于第一份实习工作，还是老老实实待下去，既呆之则安之。\n\n最近老是忧心忡忡的，也不知道怎么回事，仔细想想，也就那回事，每天上班下班挤公交，回到小窝睡大觉。\n\n可能是报考了驾校的原因，因为是之前没工作在学校报的，考了科一，直到现在车碰都没碰过。两个字：惆怅。现在也没时间回去学，不知道什么时候能拿到驾照！\n\n明天又是星期一，是我最不喜欢的一天，因为明天早上的车有个特点，那就是特别堵特别堵特别堵。。。\n\n#### 2016年5月20日星期五\n\n1、继续编写页面\n\n2、开会总结\n\n① 教育局登记系统成效及不足\n\n2016年5月22日星期天\n\n1、下午公司加班写了个页面\n\n2、开会\n\n① GuoHongYu，教育局登记系统\n\n② JiDaoMiao，至科检测工作流平台\n\n③ Me，设计院网站\n\n#### 2016年5月19日星期四\n\n1、OA debug\n\n2、编写信义东方网页\n\n#### 2016年5月18日星期三\n\n1、JS特效学习\n\n2、幼儿园系统后台界面美化\n\n3、提交一个月工作感受\n\n4、晚上会议\n\n① 月度总结\n\n② 工作日志，计划性\n\n③ 设计图定稿\n\n④ Lims系统\n\n⑤ OA\n\n#### 2016年5月17日星期二\n\n1、解决幼儿园系统时间转换问题\n\n2、电脑死机蓝屏进不了系统，重装系统\n\n3、学习前端知识\n\n4、和ChenXia沟通设计样式，分析实现效果\n\n5、晚上会议\n\n①项目部署完成，教育局报名系统告一段落\n\n②测试人员~\n\n③多浏览器的兼容性\n\n④敏捷开发\n\n⑤接下来重点Lims产品、设计院网站\n\n⑥每天的工作日志、工作状态、工作计划\n\n⑦需求分析…\n\n#### 2016年5月16日星期一\n\n1、跟随外出学习\n\n2、帮助中心\n\n3、引导页面窗口调整\n\n4、报名页面弹窗提示\n\n5、服务到期功能\n\n#### 第四周总结\n\n差不多也一个月了，第四周也结束了。本周主要围绕公司两大项目走，事情特别多，加了很多班，周日加了一整天班，周六陪女朋友一天。\n\n报名系统周一上线，希望能够完美通关。不然又要苦了我们这些实习生，一个多星期的修修补补，功能完善，测试，改bug…乐此不疲。\n\n还有就是公司内部的工作流项目，确立了新的需求，利用开源框架roadflow二次开发，个人感觉虽然节省了很多时间，但是来改人家的框架是多么不容易的一件事，有种生拽硬拉的感觉。特别不爽。不过，对于实习生的我来说，只能处理项目的边边角角。啦啦啦~\n\n本周公司发了我第一个月为期10天的实习工资，中间出了很多小波折，希望下个月发工资的时候可以解决。\n\n#### 2016年5月15日星期日\n\n1、帮助中心页面\n\n2、报名改登记\n\n3、修改图片文字\n\n4、测试...\n\n#### 2016年5月13日星期五\n\n1、教育局报名系统代码\n\n2、学会填写报销单，报销加班打车费用！\n\n3、测试教育局报名系统\n\n4、至科代码\n\n5、编写两个html页面\n\n#### 2016年5月12日星期四\n\n1、处理图片显示逻辑，房产证和购房合同上传了哪张就显示哪张，没上传显示默认图\n\n2、增加居住证图片显示，没上传显示默认图\n\n3、教育局和学校各页面图片显示，默认图片的处理\n\n4、教育局报名系统2016年秋季小学起始报名登记工作开始啦展示框\n\n5、教育局报名系统沌口片区和汉南片区登记入口页面\n\n#### 2016年5月11日星期三\n\n1、至科系统的上传与下载\n\n2、iis不安全端口解决方案\n\n3、学习教育局报名系统\n\n4、晚上会议\n\n① 针对教育局报名系统的bug做出任务划分\n\n② 教育局报名系统的逻辑梳理\n\n③ 图片显示问题\n\n#### 2016年5月10日星期二\n\n1、弹窗获取当前所选中radio的值\n\n2、文件的上传与下载\n\n3、数据绑定案例\n\n4、教育局报名系统测试\n\n5、Cookie之登录页面记住我\n\n#### 2016年5月9日星期一\n\n1、熟悉教育局报名系统代码\n\n2、至科代码\n\n3、JS控制table点击按钮增加行\n\n4、子窗体的子窗体给父窗体传值问题\n\n#### 第三周总结\n\n好快，实习第三周结束了。\n\n这周主要是针对公司的一个教育报名系统进行整改，测试。本周加了两天班，这是我第一次加班，不打卡，不记考勤，周六早早地到了公司，等了半个多小时才进去。中午经理和我们一起吃了饭，当然是他买单。\n\n本来周末两天是想要回学校的，但是计划赶不上变化，时间都奉献了。\n\n每天都在和那个特别烂的报名系统打交道，感觉好烦躁。\n\n嗯，今天是母亲节，祝全天下伟大的母亲节日快乐。\n\n这周就先这样把，明天又是一个新的开始，接下来，要给经理提交一份有关福利待遇的建议方案。\n\n打算在本月18号之前写一份“满月”体验报告。\n\n从上月18号到今天是第20天。\n\n漫漫职场程序路，何时才能到尽头？\n\n#### 2016年5月8日星期日\n\n1、教育局报名系统测试\n\n2、修改教育局报名系统存在的bug\n\n3、撰写有关福利待遇的建议方案\n\n4、浏览博客园网站，收听.NET FM，聆听时下前沿技术\n\n5、加班加到21:35，没什么想说的了\n\n#### 2016年5月7日星期六\n\n1、今天加班\n\n2、鼓捣OCR图像文字识别技术，demo案例\n\n3、教育局报名系统整合，界面美化\n\n4、整理教育局报名系统测试账号\n\n#### 2016年5月6日星期五\n\n1、去掉上传按钮，统一进行上传\n\n2、上传图片采用GUID+文件名命名，避免重名\n\n3、学会目录分离算法，避免和解决大量文件保存在同一个目录下的问题，通过目录分离算法来保证在不同的图片保存在不同的目录下。\n\n4、界面美化\n\n5、研究“以图搜图”技术,现有两种方案，具体实现有待研究\n\n① 感知哈希算法\n\n⑴ 缩小图片尺寸 将图片缩小到8x8的尺寸, 总共64个像素. 这一步的作用是去除各种图片尺寸和图片比例的差异, 只保留结构、明暗等基本信息.\n\n⑵ 转为灰度图片 将缩小后的图片, 转为64级灰度图片\n\n⑶ 计算灰度平均值 计算图片中所有像素的灰度平均值\n\n⑷ 比较像素的灰度 将每个像素的灰度与平均值进行比较, 如果大于或等于平均值记为1, 小于平均值记为0.\n\n⑸ 计算哈希值 将上一步的比较结果, 组合在一起, 就构成了一个64位的二进制整数, 这就是这张图片的指纹.\n\n⑹ 比图片指纹 得到图片的指纹后, 就可以对比不同的图片的指纹, 计算出64位中有多少位是不一样的. 如果不相同的数据位数不超过5, 就说明两张图片很相似, 如果大于10, 说明它们是两张不同的图片.\n\n② OCR图像文字识别技术\n\n因为户口本、房产证、出生证明等图片上的文字是固定的，所以可以获取户口本、房产证、出生证明等图片上的文字信息来验证图片正确与否。\n\n#### 2016年5月5日星期四\n\n1、上午会议\n\n① ChenZong对公司做介绍，现状，规划\n\n② 上市，产品\n\n③ 绩效问题\n\n④ 研发大楼\n\n⑤ 千万级智能建筑项目\n\n⑥ 分公司\\(十堰、宜昌~\\)\n\n⑦ 待遇问题\n\n2、完成GuoHongYu安排的任务，整合修改的代码\n\n3、测试教育局报名系统\n\n4、报名系统存在问题\n\n① 获取片区信息，有部分小区显示不存在\n\n② 选择特定小区“万科金域蓝湾小区”下面不隐藏\n\n③ 特定小区“滨湖小区”下一步没反应\n\n④ 所有选择房产证和购房合同页面，选择房产证没问题，选择购房合同，则会弹出提示输入门牌号和房产证\n\n#### 2016年5月4日星期三\n\n1、整个上午开会\n\n① 主题分享之图文技术点应用解析\n\n② 确定无特别情况，每周四晚组织《学习会》\n\n③ 近期的工作重点：两个系统\n\n④ 绩效考核办法讲解\n\n⑤ 教育局需求分析\n\n⑥ 公司娱乐活动建议型方案\n\n⑦ 现有问题总结，解决方案\n\n2、图片修改“报名”改“登记”\n\n3、图片上传问题异常解决\n\n4、下拉框上传不刷新\n\n5、教育局报名系统页面微调，兼容性\n\n#### 2016年5月3日星期二\n\n1、至科检测工作流平台\n\n2、搭建多层结构的博客项目\n\n3、前台登录页面\n\n4、后台登录模块\n\n5、联系人列表aspx版增删改查\n\n6、晚上会议\n\n① 教育局报名系统测试报告点评\n\n② 教育局报名系统bug修改，需求分析\n\n③ LoadRunner压力测试\n\n④ 以图搜图技术\n\n#### 2016年5月2日星期一\n\n今天是休假最后一天，\\(^o^\\)/YES!\n\n#### 第二周总结\n\n一晃半个月就这样过去了，第二周过的是那样的快，今天是五一劳动节，按国家规定我们放假三天。在紧凑的工作生活中又带来些许的放松，我刚从学校回到住处。对的，自己一个人太无聊，我跑到学校去了，去见见我那室友们。\n\n看看上面的每日任务，这周说真的，并没有学到什么，这周下发的任务很少基本上没有，所有就选择了自己安排，总的来说，学了点jQueryEasyUI、搞了一个用一般处理程序+HTML+ajax完成的增删改查小案例，哦！还有那个SQL的存储过程分页，跟进了公司的一个教育局管理系统，完成了其中的两个小模块。其它的小事就不往上面写了，大概就是这样把！\n\n渐渐地天气热了起来，夏天给人的感觉总是那么浮躁。不知为何，现在的我根本静不下心来了，没有了在学校的那种拼劲，慢慢的我感觉到自己松懈了，偏偏上班了却又没有那种特别明确的目标了。在学校的时候就想着找个公司好好实习，好好学技术，努力提升自己的价值。反而现在到了公司却有种迷茫的感觉。是自己的问题？抑或是公司的问题？\n\n仔细想了想，应该还是个人原因，就拿目前的我和之前的我对比一下：现在晚上早早地上了床，大概每晚10点多左右，就算睡不着也躺在床上。之前在学校，基本上都是12点过后才上床睡觉的，不是在敲代码，就是在看视频。\n\n不能因为现在有了一个落脚地，就因此松懈啊！还是要不断的学习才可以，既然选择了程序员这条路，就要不遗余力的去编码，去学习，学习如逆水行舟不进则退啊！除非你想一直只拿2K的薪水。这不是我想要生活，我要过上高质量的生活水平，现在的我还是远远不够的，埋头苦干才是硬道理，技术才是王道，奔跑吧，阿星！\n\n不在沉默中暴发，就在沉默中灭亡！\n\n#### 2016年4月29日星期五\n\n1、教育局报名系统测试\n\n2、教育局报名系统完善图片上传功能\n\n3、一般处理程序联系人列表的增删改查案例\n\n4、分页展示信息列表\n\n5、至科检测工作流平台表单、流程设计\n\n#### 2016年4月28日星期四\n\n1、至科检测工作流平台表单、流程设计\n\n2、Html页面+ 一般处理程序留言评论案例\n\n3、一般处理程序联系人列表的增删改查案例\n\n4、存储过程分页\n\n#### 2016年4月27日星期三\n\n1、教育局系统遮罩层图片显示功能模块\n\n2、至科检测工作流平台表单、流程设计\n\n3、ajax异步请求实现注册\n\n#### 2016年4月26日星期二\n\n1、修改网站流量统计页面代码\n\n2、学习在线投票功能案例\n\n3、学习jQueryEasyUI，搭建页面，进行增删改查操作\n\n4、晚上会议\n\n①教育局报名系统业务流程，项目介绍等\n\n②Lims产品介绍\n\n#### 2016年4月25日星期一\n\n1、观看WebApp相关资料和视频\n\n2、学习登录注册Demo后台逻辑\n\n3、学习观看新闻管理系统Demo\n\n4、学习文件上传下载Demo\n\n5、晚上会议\n\n①针对自己的学习情况，谈谈对公司上司及自己的一些看法\n\n②Boss对我们存在的一些问题进行讲解答疑\n\n③对教育局管理系统和至科实验室信息管理系统的切入、学习\n\n④教育局管理系统项目转化为产品的打算、预想\n\n⑤观看《青春代码》微电影\n\n#### 第一周总结\n\n这是我的第一次正式工作，我现在是一名大二的学生。这个时间段应该是在学校无忧无虑的过着安稳的日子的，可是我却已经出来实习了。至于为什么这么早出来找工作其实有很多原因的，有个人原因也有学校的原因，总之吧，在学校我感觉我已经学不到东西了，所以还不如早点出来锻炼锻炼自己。这个过程真的蛮艰难的，对于一个初入职场的小白来说是这样的。2016年4月15日，我的3个舍友牺牲了自己的时间帮我提行李到我所租房子的地方，打扫卫生，整理房间...真的很感谢他们，东西比较多，如果是我一个人拿的话，估计会更艰难，为表感谢，我请他们去饭店吃了一顿。\n\n我住的这个地方，距离我工作的地方，不堵车的话大概半小时的公交路程。接下来的两天，我熟悉了这里的环境，合租房，公共卫生间，真的有很多的不方便。我找的这个地方地段比较好，但是这也恰恰增加了我的经济负担，往往地段比较好的位置，消费都是比较高的。\n\n每天上班都要走很远的路程，武汉这个地方，这两年到处都在修路，真是非常的不方便。第一天上班的前一晚我特别兴奋，大晚上的在床上翻来覆去一直睡不着，早上提前了一个小时到公司，非常尴尬，因为是打卡式的，我进不去，只好在外边转了几圈直到8点左右我才上去进行一系列的入职流程。公司的上班时间是8:30--5:30，有了第一天的经验，我早上一般都是6点半起床，进行洗漱后7点准时出发，走到公交站大概7:30左右，不管堵不堵车，一个小时的缓冲时间是肯定可以到公司的。\n\n在公司按部就班的进行实习学习，我的领导个人感觉还是蛮nice的，比较人性化，喜欢和我们交流，有好几次中午都是和我们几个实习生一起走路去吃饭。一起和我实习的是我的一个学长，当时也是蛮诧异的，他和我是同一天进入这个公司的，当时还感叹了一下，这个世界其实有时候还是蛮小的。\n\n不管怎么样，这是我的第一份工作，我希望自己能够做好，不断增强自己，早日达到标准。\n\n#### 2016年4月22日星期五\n\n1、熟悉教育局报名管理系统后台逻辑\n\n2、完成GuoHongYu分配的任务\n\n3、学习三层架构\n\n#### 2016年4月21日星期四\n\n1、完成图片上传之前本地预览功能\n\n2、上午会议\n\n① Jin日里程碑提交规范\n\n② Lims观后感或者测试报告点评\n\n③ 近期任务：配合GuoHongYu安排的任务、学习\n\n④ C\\#开发编码规范\n\n3、学习RoadFlow工作流引擎，教育局报名管理系统\n\n4、来游戏•复盘设计方案分析\n\n5、研究H5 APP开发 - WeX5\n\n#### 2016年4月20日星期三\n\n1、继续观看信息系统，并写观后感\n\n2、仿淘宝图片大图显示js代码特效\n\n3、图片上传之前本地预览功能\n\n#### 2016年4月19日星期二\n\n1、登陆系统练习\n\n2、在线观看至科实验室信息管理系统\n\n#### 2016年4月18日星期一\n\n1、第一天上班，配置电脑，熟悉环境\n\n2、登录系统练习\n",
        "category": "Summary",
        "tag": [
            "工作总结",
            "实习",
            "总结"
        ],
        "createdAt": "2017-05-31 16:00:00"
    },
    {
        "title": "2017年终总结",
        "author": "阿星Plus",
        "url": "2018-01-02-2017-summary",
        "markdown": "眼看17年就要过去了，还是动动手指向自己汇报汇报今年的流水账吧！\n\n2017年2月10日我辞掉了第一家公司的实习工作，在武汉陪着女朋友嗨了一周之后独自一人踏上了前往魔都上海的旅途。至此，魔都漂泊的日子正式开始了。\n\n在经历了几天的挤地铁，投简历和一系列面试之后，于2017年2月22日正式拿到上海盖世汽车网络技术有限公司的offer。\n\n接下来便是找房子、租房子、熟悉环境，五天之后正式入职。\n\n4月份请假回校答辩，6月底再次回校，大学生涯结束了，正式毕业拿到毕业证，顺便还正式成为了一名中华人民共和国党员。\n\n2017年7月正式签订劳动合同，转正，实习期结束。\n\n一晃一年过去了，这一年我过的很充实，虽然很辛苦但是乐在其中。\n\n作为一名程序员，最开心的莫过于技术的提升。这一年的工作中，接触了许多新技术，我也不断学习着进步着。\n\n刚从学校走出来的我，主要做web开发，其它的都只是有所了解浅尝辄止，从来没有真正的去做过项目，借着公司的项目，现在会了微信小程序开发、Native App开发。\n\n在公司主要用.NET开发网站，写写脚本，小工具，爬虫等等。慢慢接触了ReactNative、APICloud、WebApi、WebService、.Net MVC、.Net Core、Linux、Nginx、微信小程序，并且能够上手简单使用，同时做了几个网站，小程序和App 并且全部上线使用中。\n\n新的一年，给自己先定一个不能达到的小目标，比方说我先挣它一个亿。\n",
        "category": "Summary",
        "tag": [
            "年终总结",
            "总结",
            "2017"
        ],
        "createdAt": "2018-01-02 13:01:11"
    },
    {
        "title": "2018年终总结",
        "author": "阿星Plus",
        "url": "2019-01-14-2018-summary",
        "markdown": "不知不觉中，已经2019了，今天来写写我迟到的年终总结。\n\n时间真是个好东西啊，每个人每天都拥有短短的24小时，转眼间从毕业实习到正式工作都过去差不多两年了。如此多的24小时，真是值得回味呢！\n\n依稀记得，2018年2月19大年初四爸妈不舍的神情，因为路途遥远加上初七就要上班，不得不提前离开老家返程回到上海。路上我就在想，今年一定要努力工作，攒点钱孝敬孝敬父母，他们的年纪慢慢也大了，而我也老大不小了……\n\n今年，利于闲暇时间看完了以下6本书，以及在读的就不列出了。\n\n* 《马伯庸笑翻中国简史》 ——马伯庸\n* 《腾讯传》 ——吴晓波\n* 《白说》 ——白岩松\n* 《没事别随便思考人生》 ——鬼脚七\n* 《看见》 ——柴静\n* 《三体》 ——刘慈欣\n\n读书，是我一直想做却一直没时间没坚持下去的一件事。现在是利用晚上睡觉前的时间进行阅读。书中的内容总是让人放松，可以领略作者笔下的世界。\n\n我所在的公司还是老传统的WebForm开发模式，框架甚至还停留在 .NET Framework 4，所有的系统软件都只能运行在Windows上面。所以自己今年系统学习了一下微软开源框架 .NET Core的开发和使用，还利用周末，下班时间做了几个外包项目。了解并会简单使用开源监控软件Zabbix，利用Zabbix API二次开发获取数据与现有后台进行通信、结合百度开源图表神器ECharts，展示大屏报表数据、学会如何将开发的网站部署至Linux以及简单的Linux命令行学习、开发了一个具有多语言的内网穿透管理系统，充分体验了 .NET Core的优越和便利。by the way，希望在以后的工作中，可以找 .NET Core开发的相关工作。\n\n工作上，一个项目接着一个项目的做着，需求是源源不断的，你会发现当你做完一件事情，总会有另外一件事情等着你的，公司是不可能让你闲下来，毕竟不养闲人嘛。以往的我总是焦虑，烦躁。现在的我则不会了。因为懂得了一个道理，事情总是源源不断的，不必去纠结烦恼，没有什么事是解决不了的，只要你静下心去想一想，思考一下解决办法，时间总是会证明这一切都是可以解决。在做项目写代码的时候也是一样的道理，没有解决不了的bug，没有完成不了的任务。不断去学习、思考，可以解决一切麻烦事。\n\n在上海的一年又过去了，这一年没有回过一次家，所以向公司申请了四天年假买了1月28号的火车票想早一点回家多陪陪家人\\(请年假的这件事，期间出现了很多不愉快，之前V2EX社区闹得沸沸扬扬的帖子就是本人，详见：[https://www.v2ex.com/t/522131](https://www.v2ex.com/t/522131) ，好在最后请假顺利\\)。\n\n写着写着，脑海出现了两首歌，《这个年纪》、《像我这样的人》。不是因为歌好听而是觉得歌词写得像自己。\n\n所以，加油吧少年，美好未来在明天。",
        "category": "Summary",
        "tag": [
            "年终总结",
            "总结",
            "2018"
        ],
        "createdAt": "2019-01-14 15:20:00"
    },
    {
        "title": "HTML页面全屏和退出全屏",
        "author": "阿星Plus",
        "url": "2018-10-27-screenfull",
        "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>页面全屏/退出全屏</title>\n</head>\n\n<body>\n    <a class=\"screen-full\" id=\"full\" href=\"javascript:;\">全屏</a>\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\n$('#full').click(function() {\n    var ele = document.documentElement;\n    var SCREEN_FULL_TEXT = \"全屏\";\n    var SCREEN_REST_TEXT = \"退出全屏\";\n    var SCREEN_FULL = 'screen-full';\n    var SCREEN_REST = 'screen-restore';\n    var iconElem = $(this);\n    if (iconElem.hasClass(SCREEN_FULL)) {\n        var reqFullScreen = ele.requestFullScreen || ele.webkitRequestFullScreen || ele.mozRequestFullScreen || ele.msRequestFullscreen;\n        if (typeof reqFullScreen !== 'undefined' && reqFullScreen) {\n            reqFullScreen.call(ele);\n        };\n        iconElem.addClass(SCREEN_REST).removeClass(SCREEN_FULL);\n        iconElem.text(SCREEN_REST_TEXT);\n    } else {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n        } else if (document.webkitCancelFullScreen) {\n            document.webkitCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        }\n        iconElem.addClass(SCREEN_FULL).removeClass(SCREEN_REST);\n        iconElem.text(SCREEN_FULL_TEXT);\n    }\n});\n</script>\n```\n",
        "category": "Web",
        "tag": [
            "HTML",
            "全屏"
        ],
        "createdAt": "2018-10-27 00:08:00"
    },
    {
        "title": "HTML多图无缝循环翻页效果",
        "author": "阿星Plus",
        "url": "2018-08-24-loop-page",
        "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>多图无缝循环翻页效果</title>\n    <style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    .carousel {\n        width: 1000px;\n        height: 500px;\n        margin: 0 auto;\n        overflow: hidden;\n    }\n\n    .carousel ul li {\n        width: 1000px;\n        height: 500px;\n        list-style-type: none;\n        float: left;\n    }\n\n    .carousel ul li a img {\n        width: 100%;\n        height: 100%;\n        object-fit: contain;\n    }\n    </style>\n</head>\n\n<body>\n    <div class=\"carousel\">\n        <ul>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"1\">\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"2\">\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"3\">\n                </a>\n            </li>\n        </ul>\n    </div>\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\nvar carousel = $('.carousel ul'),\n    li = $('.carousel ul li');\ncarousel.css('width', li.width() * li.length);\nsetInterval(function() {\n    carousel.animate({\n        'marginLeft': -li.width()\n    }, 500, function() {\n        $(this).animate({ 'marginLeft': 0 }, 0)\n            .find('li').eq(0).appendTo($(this));\n    });\n}, 3000);\n</script>\n```\n",
        "category": "Web",
        "tag": [
            "HTML",
            "翻页"
        ],
        "createdAt": "2018-08-24 14:11:00"
    },
    {
        "title": "HTML60秒倒计时",
        "author": "阿星Plus",
        "url": "2018-04-19-countdown",
        "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>60秒倒计时</title>\n</head>\n\n<body>\n    <input type=\"button\" id=\"btn\" value=\"获取验证码\" onclick=\"sendemail()\" />\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\nvar countdown = 5\n\nfunction sendemail() {\n    var obj = $(\"#btn\")\n    settime(obj)\n    console.log('发送邮件')\n}\n\nfunction settime(obj) {\n    if (countdown == 0) {\n        obj.attr('disabled', false)\n        obj.val(\"获取验证码\")\n        countdown = 5\n        return\n    } else {\n        obj.attr('disabled', true)\n        obj.val(\"重新发送(\" + countdown + \")\")\n        countdown--\n    }\n    setTimeout(function() {\n        settime(obj)\n    }, 1000)\n}\n</script>\n```\n",
        "category": "Web",
        "tag": [
            "HTML",
            "倒计时"
        ],
        "createdAt": "2018-04-19 17:34:00"
    },
    {
        "title": "一些精简的JavaScript代码集合",
        "author": "阿星Plus",
        "url": "2019-07-22-js-code",
        "markdown": "## 日历\n\n创建过去七天的数组，如果将代码中的减号换成加号，你将得到未来7天的数组集合\n\n```javascript\n// 创建过去七天的数组\n[...Array(7).keys()].map(days => new Date(Date.now() - 86400000 * days));\n```\n\n## 生成随机ID\n\n生成长度为11的随机字母数字字符串\n\n```javascript\n// 生成长度为11的随机字母数字字符串\nMath.random().toString(36).substring(2);\n```\n\n## 获取URL的查询参数\n\n这个获取URL的查询参数代码，是我见过最精简的\n\n```javascript\n// 获取URL的查询参数\nq={};location.search.replace(/([^?&=]+)=([^&]+)/g,(_,k,v)=>q[k]=v);q;\n```\n\n## 本地时间\n\n通过一堆HTML，您可以创建一个本地时间，其中包含您可以一口气读出的源代码，它每秒都会用当前时间更新页面\n\n```javascript\n// 创建本地时间\n<body onload=\"setInterval(()=>document.body.innerHTML=new Date().toLocaleString().slice(10,19))\"></body>\n```\n\n## 数组混淆\n\n随机更改数组元素顺序，混淆数组\n\n```(arr) => arr.slice().sort(() => Math.random() - 0.5)```\n\n```javascript\n// 随机更改数组元素顺序，混淆数组\nlet a = (arr) => arr.slice().sort(() => Math.random() - 0.5)\nlet b = a([1,2,3,4,5])\nconsole.log(b)\n```\n\n## 生成随机十六进制代码（生成随机颜色）\n\n使用JavaScript简洁代码生成随机十六进制代码\n\n```javascript\n// 生成随机十六进制代码 如：'#c618b2'\n'#' + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, '0');\n```\n\n## 数组去重\n\n这是一个原生的JS函数但是非常简洁，Set接受任何可迭代对象，如数组[1,2,3,3]，并删除重复项\n\n```javascript\n// 数组去重\n[...new Set(arr)]\n```\n\n## 创建特定大小的数组\n\n```javascript\n[...Array(3).keys()]\n// [0, 1, 2]\n\nArray.from({length: 3}, (item, index) => index)\n// [0, 1, 2]\n```\n\n## 返回一个键盘\n\n```javascript\n// 用字符串返回一个键盘图形\n(_=>[...\"`1234567890-=~~QWERTYUIOP[]\\\\~ASDFGHJKL;'~~ZXCVBNM,./~\"].map(x=>(o+=`/${b='_'.repeat(w=x<y?2:' 667699'[x=[\"BS\",\"TAB\",\"CAPS\",\"ENTER\"][p++]||'SHIFT',p])}\\\\|`,m+=y+(x+'    ').slice(0,w)+y+y,n+=y+b+y+y,l+=' __'+b)[73]&&(k.push(l,m,n,o),l='',m=n=o=y),m=n=o=y='|',p=l=k=[])&&k.join`\n`)()\n```\n",
        "category": "Web",
        "tag": [
            "JavaScript"
        ],
        "createdAt": "2019-07-22 21:10:45"
    },
    {
        "title": "执行超大sql文件",
        "author": "阿星Plus",
        "url": "2018-01-24-execute-sql",
        "markdown": "```sql\nosql -S 127.0.0.1 -U sa -P 123456 -i d:\\test.sql\n```\n\n#### osql为SQL Server的命令，在cmd中执行该命令，一般安装完SQL Server后该命令对应的路径会自动添加到系统环境变量中\n\n* S 表示要连接的数据库服务器\n* U 表示登录的用户ID\n* P 表示登录密码\n* i 表示要执行的脚本文件路径\n",
        "category": "Database",
        "tag": [
            "SqlServer",
            "SQL"
        ],
        "createdAt": "2018-01-24 10:04:00"
    },
    {
        "title": "游标循环处理数据",
        "author": "阿星Plus",
        "url": "2018-06-20-cursor",
        "markdown": "在开发中，经常会遇到一个场景。需要批量处理数据，循环添加、删除、修改一些数据。\n\n**需求：**\n\n有 文章表（dbo.Gas\\_Article）、文章作者表（dbo.Gas\\_ArticleAuthor）\n\n现在需要在后台统计出每个作者共发布了多少文章，和所有文章阅读量之和的数据\n\n**以下是我的处理方案：**\n\n编写PROCEDURE，内部利用游标循环处理数据，然后使用SqlServer代理，新建一个作业定时任务处理，这样就可以在后台实时统计了。\n\n```sql\nCREATE PROCEDURE Job_UpdateAuthor --创建PROCEDURE\nAS\n    BEGIN\n        DECLARE UpdateAuthorCursor CURSOR --定义游标\n        FOR\n            SELECT  COUNT(*) AS ArticleNumber ,\n                    SUM(ShowHits) AS ArticleHits ,\n                    Author\n            FROM    dbo.Gas_Article\n            WHERE   Author IN ( SELECT  Name\n                                FROM    dbo.Gas_ArticleAuthor\n                                WHERE   IsDelete = 0 )\n            GROUP BY Author --查出需要的数据至游标中\n\n        OPEN UpdateAuthorCursor --打开游标\n\n        DECLARE @Number INT, @Hits INT, @Author NVARCHAR(255)\n        FETCH NEXT FROM UpdateAuthorCursor INTO @Number, @Hits, @Author --读取第一行数据，赋值给变量\n\n        WHILE @@FETCH_STATUS = 0\n            BEGIN\n                UPDATE  dbo.Gas_ArticleAuthor\n                SET     ArticleNumber = @Number ,\n                        ArticleHits = @Hits\n                WHERE   Name = @Author -- 更新dbo.Gas_ArticleAuthor数据\n\n                FETCH NEXT FROM UpdateAuthorCursor INTO @Number, @Hits, @Author --读取下一行数据\n            END\n\n        CLOSE UpdateAuthorCursor --关闭游标\n\n        DEALLOCATE UpdateAuthorCursor --释放游标\n    END\nGO\n```\n\n",
        "category": "Database",
        "tag": [
            "SqlServer",
            "SQL",
            "cursor"
        ],
        "createdAt": "2018-06-20 08:45:00"
    },
    {
        "title": "Windows下MySQL安装流程，8.0以上版本ROOT密码报错及修改",
        "author": "阿星Plus",
        "url": "2019-07-29-mysql-install",
        "markdown": "官网下载MySQL安装后，解压，添加环境变量，以管理员方式运行cmd，运行以下命令\n\n```text\nmysqld --initialize --console\nmysqld -install\n\nnet start mysql\nnet stop mysql\n```\n\n以上命令走完，确保MySQL安装和启动没问题，第一次安装设置密码\\(忘记密码也适用\\)\n\n运行：`mysqld --shared-memory --skip-grant-tables`\n\n此时命令提示符窗口处于锁定状态，我们重新以管理员方式运行新的cmd，运行以下命令\n\n```text\nmysql -uroot -p\n```\n\n提示输入密码时直接按回车进入，输入\n\n```text\nuse mysql;\nalter user 'root'@'localhost' identified by '123456';\nflush privileges;\n```\n\n123456就是要设置的密码，退出MySQL交互环境，再次启动MySQL服务，用设置的密码连接MySQL\n",
        "category": "Database",
        "tag": [
            "MySQL",
            "Windows"
        ],
        "createdAt": "2019-07-29 22:28:28"
    },
    {
        "title": "MongoDB Shell 命令",
        "author": "阿星Plus",
        "url": "2019-07-21-mongodb-shell",
        "markdown": "更新列名\n\n```sql\ndb.Stores.update({}, {$rename : {\"StoreId\" : \"MetaId\"}}, false, true)\n```\n\n查询长度\n\n```sql\ndb.getCollection(\"Stores_Navigations\").find({$where:'this.StoreId.length>2'},{Name:0})\n```\n\n查询总条数\n\n```sql\ndb.getCollection(\"Stores_BusinessLogs\").find({}).count()\n```\n\n区间查询\n\n```sql\ndb.getCollection(\"Cards\").find({'StoreId':1139,'CardNo':{'$gte':'90225001','$lte':'90295000'}})\n```\n\n排序 1升序 -1降序\n\n```sql\ndb.getCollection(\"Stores_BusinessLogs\").find().sort({\"CreationTime\":1})\n```\n\n更改字段类型\n\n```sql\n// 16代表int\ndb.Stores_Experts.find({'PicId' : { $type : 16 }}).forEach(function(x) {x.PicId = String(x.PicId);db.Stores_Experts.save(x); })\n```\n\n字段类型表\n\n| 类型 | 对应数字 | 别名 |\n| :--- | :--- | :--- |\n| Double | 1 | double |\n| String | 2 | string |\n| Object | 3 | object |\n| Array | 4 | array |\n| Binary data | 5 | binData |\n| Undefined | 6 | undefined |\n| ObjectId | 7 | objectId |\n| Boolean | 8 | “bool” |\n| Date | 9 | “date” |\n| Null | 10 | “null” |\n| Regular Expression | 11 | “regex” |\n| DBPointer | 12 | “dbPointer” |\n| JavaScript | 13 | “javascript” |\n| Symbol | 14 | “symbol” |\n| JavaScript\\(with scope\\) | 15 | “javascriptWithScope” |\n| 32-bit integer | 16 | “int” |\n| Timestamp | 17 | “timestamp” |\n| 64-bit integer | 18 | “long” |\n| Min key | -1 | “minKey” |\n| Max key | 127 | “maxKey” |\n| - | - | - |\n\n添加一个字段. table 代表表名 , 添加字段 content,字符串类型\n\n```sql\ndb.table.update({}, {$set: {content:\"\"}}, {multi: true})\n```\n\n删除一个字段\n\n```sql\ndb.table.update({},{$unset:{content:\"\"}},false, true)\n```\n\n清空数据\n\n```sql\ndb.table.remove({})\n```\n\n查询指定列\n\n```sql\ndb.news.find( {}, { id: 1, title: 1 } )\n```\n\n修改列表\n\n```sql\ndb.getCollection('Orders_Scores').update({},{$rename:{\"OId\":'MetaId'}},false,true)\n```\n\n添加索引\n\n```sql\ndb.test.createIndex({\"username\":1})\ndb.Users_MobileAuthCodes.createIndex({\"Code\":1,\"Mobile\":1,\"ExpiresTime\":1},{\"name\":\"MobileAuthCodes_Validate\"})\n```\n\ngroup分组\n\n```sql\ndb.getCollection(\"Users_GaoKaoScores\").aggregate([{$match:{\"IsDeleted\":false}},{$group : {_id : \"$UserId\", count : {$sum : 1}}},{$sort:{\"count\":-1}}])\n```\n\n按条件修改update\n\n```sql\ndb.getCollection('Stores_Navigations').update( \n    // query\n    {\n        \"MenuKey\" : 28\n    },\n\n    // update\n    {\n        $set:{\"Url\":\"/tzy/choosebatch?type=3\"}\n    },\n    false,  \n    true\n);\n```\n",
        "category": "Database",
        "tag": [
            "MongoDB",
            "SQL"
        ],
        "createdAt": "2019-07-21 22:17:01"
    },
    {
        "title": "Redis快速入门及使用",
        "author": "阿星Plus",
        "url": "2019-07-24-quick-start-with-redis",
        "markdown": "## 概述\n\nredis是一种支持分布式的nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比memcached支持更多的数据结构(string,list列表[队列和栈],set[集合],sorted set[有序集合],hash(hash表))。\n\nredis文档：http://redisdoc.com/index.html\n\n## Redis使用场景\n\n- 登录会话存储：存储在redis中，与memcached相比，数据不会丢失。\n- 排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。\n- 作为消息队列：比如celery就是使用redis作为中间人。\n- 当前在线人数：当前系统有多少在线人数。\n- 一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从mysql中获取，可以在redis中缓存起来，不用每次请求数据库。\n- 把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。\n- 好友关系：微博的好友关系使用redis实现。\n- 发布和订阅功能：可以用来做聊天软件。\n\n## Redis和Memcached的比较\n\n|  | Memcached | Redis |\n| :--- | :--- | :--- |\n| 类型 | 纯内存数据库 | 内存磁盘同步数据库 |\n| 数据类型 | 在定义value时就要固定数据类型 | 不需要 |\n| 虚拟内存 | 不支持 | 支持 |\n| 过期策略 | 支持 | 支持 |\n| 存储数据安全 | 不支持 | 可以将数据同步到dump.db中 |\n| 灾难恢复 | 不支持 | 可以将磁盘中的数据恢复到内存中 |\n| 分布式 | 支持 | 主从同步 |\n| 订阅与发布 | 不支持 | 支持 |\n\n## Redis在windows系统中的安装与启动\n\n- 下载：redis官方是不支持windows操作系统的，但是微软的开源部门将redis移植到了windows上，因此下载地址不是在redis官网上，而是在github上：https://github.com/MicrosoftArchive/redis/releases\n- 安装：点击一顿下一步安装就可以了\n- 运行：进入到redis安装所在的路径然后执行```redis-server.exe redis.windows.conf```就可以运行了\n- 连接：redis和mysql以及mongo是一样的，都提供了一个客户端进行连接。输入命令redis-cli（前提是redis安装路径已经加入到环境变量中了）就可以连接到redis服务器了\n\n## Redis在ubuntu系统中的安装与启动\n\n- 安装：```sudo apt-get install redis-server```\n- 卸载：```sudo apt-get purge --auto-remove redis-server```\n- 启动：redis安装后，默认会自动启动，可以通过以下命令查看：```ps aux|grep redis```\n- 如果想自己手动启动，可以通过以下命令进行启动：```sudo service redis-server start```\n- 停止：```sudo service redis-server stop```\n\n## Redis服务器允许其它机器访问\n\n- 想要让其他机器访问本机的redis服务器。那么要修改redis.conf的配置文件，将bind改成bind [自己的ip地址或者0.0.0.0]，其他机器才能访问。\n- bind绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址。如果绑定到额是0.0.0.0，那么意味着其他机器可以通过本机所有的ip地址进行访问。\n\n## 对Redis的操作\n\n操作redis可以分为两种方式，第一种是使用redis-cli，第二种就是使用编程语言对其操作， 如：.NET、Python等\n\n### 启动redis\n\n```sudo service redis-server start```\n\n### 连接redis-server\n\n```redis-cli -h [ip] -p [端口]```\n\n### 添加\n\n```set key value``` 如：```set key articles```\n\n将字符串值value关联到key。如果key已经持有其他值，set命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。\n\n### 删除\n\n```del key``` 如：```del articles```\n\n### 设置过期时间\n\n```expire key timeout(单位为秒)```\n\n也可以在设置值的时候，一同指定过期时间\n\n```set key value EX timeout``` 或：```setex key timeout value```\n\n### 查看过期时间\n\n```ttl key``` 如：```ttl articles```\n\n### 查看当前redis中的所有key\n\n```keys *```\n\n### 列表操作\n\n- 在列表左边添加元素\n\n    ```lpush key value```\n\n    将值value插入到列表key的表头。如果key不存在，一个空列表会被创建并执行lpush操作。当key存在但不是列表类型时，将返回一个错误\n\n- 在列表右边添加元素\n\n    ```rpush key value```\n\n    将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误\n\n- 查看列表中的元素\n\n    ```lrange key start stop```\n\n    返回列表key中指定区间内的元素，区间以偏移量start和stop指定,如果要查看左边的第一个到最后的一个则：```lrange key 0 -1```\n\n- 移除列表中的元素\n\n    - 移除并返回列表key的头元素：```lpop key```\n    - 移除并返回列表的尾元素：```rpop key```\n    - 移除并返回列表key的中间元素：```lrem key count value``` 将删除key这个列表中，count个值为value的元素\n\n- 指定返回第几个元素\n\n    ```lindex key index``` 将返回key这个列表中，索引为index的这个元素\n\n- 获取列表中的元素个数\n\n    ```llen key``` 如：```llen languages```\n\n    根据参数 count 的值，移除列表中与参数 value 相等的元素。count的值可以是以下几种\n\n    - count > 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count\n    - count < 0：从表尾开始向表头搜索，移除与 value相等的元素，数量为count的绝对值\n    - count = 0：移除表中所有与value 相等的值\n\n### set集合的操作\n\n- 添加元素\n\n    ```sadd set value1 value2....``` 如：```sadd team web app```\n\n- 查看元素\n\n    ```smembers set``` 如：```smembers team```\n\n- 移除元素\n\n    ```rem set member...``` 如：```srem team web app```\n\n- 查看集合中的元素个数\n\n    ```scard set``` 如：```scard team1```\n\n- 获取多个集合的交集\n\n    ```sinter set1 set2``` 如：```sinter team1 team2```\n\n- 获取多个集合的并集\n\n    ```sunion set1 set2``` 如：```sunion team1 team2```\n\n- 获取多个集合的差集\n\n    ```sdiff set1 set2``` 如：```sdiff team1 team2```\n\n### hash哈希操作\n\n- 添加一个新值\n\n    ```hset key field value``` 如：```hset website baidu baidu.com```\n\n    将哈希表key中的域field的值设为value，如果key不存在，一个新的哈希表被创建并进行 HSET操作。如果域 field已经存在于哈希表中，旧值将被覆盖。\n\n- 获取哈希中的field对应的值\n\n    ```hget key field``` 如：```hget website baidu```\n\n- 删除field中的某个field\n\n    ```hdel key field``` 如：```hdel website baidu```\n\n- 获取某个哈希中所有的field和value\n\n    ```hgetall key``` 如：```hgetall website```\n\n- 获取某个哈希中所有的field\n\n    ```hkeys key``` 如：```hkeys website```\n\n- 获取某个哈希中所有的值\n\n    ```hvals key``` 如：```hvals website```\n\n- 判断哈希中是否存在某个field\n\n    ```hexists key field``` 如：```hexists website baidu```\n\n- 获取哈希中总共的键值对\n\n```hlen field``` 如：```hlen website```\n\n### 事务操作\n\nRedis事务可以一次执行多个命令，事务具有以下特征\n\n- 隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰\n- 原子操作：事务中的命令要么全部被执行，要么全部都不执行\n- 开启一个事务：```multi```，以后执行的所有命令，都在这个事务中执行的\n- 执行事务：```exec```，会将在```multi```和```exec```中的操作一并提交\n- 取消事务：```discard```，会将```multi```后的所有命令取消\n- 监视一个或者多个key：```watch key...```，监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断\n- 取消所有key的监视：```unwatch```\n\n### 发布/订阅操作\n\n- 给某个频道发布消息：```publish channel message```\n- 订阅某个频道的消息：```subscribe channel```\n",
        "category": "Database",
        "tag": [
            "Redis"
        ],
        "createdAt": "2019-07-24 22:18:28"
    },
    {
        "title": "基于.NET Core开发的个人博客发布至CentOS小计",
        "author": "阿星Plus",
        "url": "2019-08-15-centos-usage",
        "markdown": "早些时候，使用 .NET Framework 开发网站，只能部署在 Windows 服务器上面，近两年 .NET Core 如火如荼，乘此机会赶紧上车，最近将自己利用 .NET Core 开发的个人博客发布在了 CentOS 上，简单记录一下使用过程和一些常用的命令，以备不时之需。\n\n## 渣渣服务器配置信息\n\n- 操作系统 CentOS 7.6 64 位\n- CPU 1 核\n- 内存 1 GB\n- 公网带宽 1 Mbps\n\n## 强大的管理工具\n\n- Xshell：强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。\n- WinSCP：WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件\n- Xftp：Xftp 是一个功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 以后，MS Windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。\n\n## 安装 .NET Core SDK\n\n```shell\nsudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm\n\nsudo yum update\nsudo yum install dotnet-sdk-2.2\n\ndotnet --info\n```\n\n## 安装 Nginx\n\n```shell\ncurl -o  nginx.rpm http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\nrpm -ivh nginx.rpm\n\nyum install nginx\n\nsystemctl start nginx #启动nginx\nsystemctl enable nginx #设置nginx的开机启动\n```\n\n## Nginx 配置\n\n```shell\nserver {\n        listen 443 ssl;\n        server_name meowv.com;\n        ssl_certificate ssl/1_meowv.com_bundle.crt;\n        ssl_certificate_key ssl/2_meowv.com.key;\n        ssl_session_timeout 5m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n        ssl_prefer_server_ciphers on;\n        # error_page 403 https://meowv.com;\n        location / {\n            # add_header Access-Control-Allow-Origin *;\n            # root   /qix/static;\n            proxy_pass http://localhost:5000;\n            proxy_set_header   X-Real-IP        $remote_addr;\n            proxy_set_header   Host             $host;\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        }\n}\n\nserver {\n    listen 80;\n    server_name meowv.com;\n    rewrite ^(.*)$ https://meowv.com;\n}\n```\n\n## 安装 Supervisor 守护进程\n\n```shell\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n## 配置 Supervisor\n\n找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释并修改为\n\n```shell\n[include]\nfiles = conf.d/*.ini\n```\n\n在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建 meowv.conf 文件，内容为\n\n```shell\n[program:meowv] #meowv为程序名称\ncommand=dotnet MeowvBlog.Web.dll #执行的命令\ndirectory=/qix/meowv # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production #环境变量\nuser=root #用户\nstopsignal=INT\nautostart=true #是否自启动\nautorestart=true #是否自动重启\nstartsecs=3 #自动重启时间间隔（s）\nstderr_logfile=/var/log/meowv.com.err.log #错误日志文件\nstdout_logfile=/var/log/meowv.com.out.log #输出日志文件\n```\n\n## 利用 crontab 定时执行 Python 爬虫任务\n\n在 Windows 平台我们可以使用任务计划程序运行定时任务，那么在 Linux 下有 crontab 帮我们实现\n\n可以用`crontab -e`命令来编辑`/var/spool/cron`下对应用户的`cron`文件，也可以直接编辑`/etc/crontab`\n\n```shell\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n*/30 * * * * /bin/python /qix/spider/spider.py #每30分钟执行一次\n\n```\n\n```shell\nsystemctl start  crond.service #启动\nsystemctl status  crond.service #查看状态\nsystemctl stop  crond.service #停止\nsystemctl restart  crond.service #重新启动\nsystemctl reload  crond.service #重新加载\n```\n\n## 常用命令\n\n```shell\ncd                 #目录跳转\ncd /               #回到根目录\nls                 #查看目录下的文件\ndf -h              #查看文件使用情况\nmkdir              #创建文件夹文件夹\nvi                 #编辑文件\n:wq!               #保存文件，并退出vi\nifconfig -a        #查看ip\nfree               #查看系统资源使用情况\nreboot             #重启系统\nnginx -s reload    #刷新nginx配置使其生效\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Python",
            "CentOS",
            "Linux",
            "Nginx",
            "Supervisor",
            "crontab",
            "shell"
        ],
        "createdAt": "2019-08-15 13:12:06"
    },
    {
        "title": "利用SQL生成模型实体类",
        "author": "阿星Plus",
        "url": "2019-08-19-sql2model",
        "markdown": "```sql\nDECLARE @TableName sysname = 'TableName';\n\nDECLARE @Result VARCHAR(MAX) = 'public class ' + @TableName + '\n{';\n\nSELECT @Result = @Result + '\n\t/// <summary>\n    /// '        + CAST(t.Summary AS VARCHAR(MAX)) + '\n    /// </summary>\n    public '     + ColumnType + NullableSign + ' ' + ColumnName + ' { get; set; }\n'\nFROM\n(\n    SELECT REPLACE(col.name, ' ', '_') ColumnName,\n           col.column_id ColumnId,\n           CASE typ.name\n               WHEN 'bigint' THEN\n                   'long'\n               WHEN 'binary' THEN\n                   'byte[]'\n               WHEN 'bit' THEN\n                   'bool'\n               WHEN 'char' THEN\n                   'string'\n               WHEN 'date' THEN\n                   'DateTime'\n               WHEN 'datetime' THEN\n                   'DateTime'\n               WHEN 'datetime2' THEN\n                   'DateTime'\n               WHEN 'datetimeoffset' THEN\n                   'DateTimeOffset'\n               WHEN 'decimal' THEN\n                   'decimal'\n               WHEN 'float' THEN\n                   'float'\n               WHEN 'image' THEN\n                   'byte[]'\n               WHEN 'int' THEN\n                   'int'\n               WHEN 'money' THEN\n                   'decimal'\n               WHEN 'nchar' THEN\n                   'char'\n               WHEN 'ntext' THEN\n                   'string'\n               WHEN 'numeric' THEN\n                   'decimal'\n               WHEN 'nvarchar' THEN\n                   'string'\n               WHEN 'real' THEN\n                   'double'\n               WHEN 'smalldatetime' THEN\n                   'DateTime'\n               WHEN 'smallint' THEN\n                   'short'\n               WHEN 'smallmoney' THEN\n                   'decimal'\n               WHEN 'text' THEN\n                   'string'\n               WHEN 'time' THEN\n                   'TimeSpan'\n               WHEN 'timestamp' THEN\n                   'DateTime'\n               WHEN 'tinyint' THEN\n                   'byte'\n               WHEN 'uniqueidentifier' THEN\n                   'Guid'\n               WHEN 'varbinary' THEN\n                   'byte[]'\n               WHEN 'varchar' THEN\n                   'string'\n               ELSE\n                   'UNKNOWN_' + typ.name\n           END ColumnType,\n           CASE\n               WHEN col.is_nullable = 1\n                    AND typ.name IN ( 'bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal',\n                                      'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint',\n                                      'smallmoney', 'time', 'tinyint', 'uniqueidentifier'\n                                    ) THEN\n                   '?'\n               ELSE\n                   ''\n           END NullableSign,\n           ISNULL(ep.value, col.name) AS Summary\n    FROM sys.columns col\n        JOIN sys.types typ\n            ON col.system_type_id = typ.system_type_id\n               AND col.user_type_id = typ.user_type_id\n        LEFT JOIN sys.extended_properties ep\n            ON ep.major_id = col.object_id\n               AND ep.minor_id = col.column_id\n    WHERE col.object_id = OBJECT_ID(@TableName)\n) t\nORDER BY ColumnId;\n\nSET @Result = @Result + '\n}';\n\nPRINT @Result;\n```",
        "category": "Database",
        "tag": [
            "SqlServer",
            "SQL",
            "model"
        ],
        "createdAt": "2019-08-19 21:22:09"
    },
    {
        "title": "EPPlus.Core 处理 Excel 报错之天坑 WPS",
        "author": "阿星Plus",
        "url": "2019-08-21-epplus-wps-error",
        "markdown": "最近工作中常常有有数据处理的需求，一个Excel动不动就是上十万的数据量，在用 EPPlus.Core 导入数据入库的时候遇到了一个莫名其妙的问题 `The given key 'rId2' was not present in the dictionary.`\n\n我TM一个导入Excel，解析数据哪里来的 dictionary???\n\n然后开始了艰辛的调试debug之旅，反复上传导入都不行，然后自己创建了一个格式相同数据量比较少的Excel文件上传，成功。\n\n这时候我大概知道是什么问题了，给Excel数据的同事用的是WPS(这辈子都不会用的东东...)，由于EPPlus对WPS支持度不怎么友好，所以导致解析数据的时候出错，将WPS保存的Excel文件用Office Excel打开另存为一个新的文件，再上传解析，成功。\n\n```csharp\npublic async Task<ActionOutput> ProcessExcelData(IFormFile ExcelFile)\n{\n    using (var package = new ExcelPackage(ExcelFile.OpenReadStream()))\n    {\n        var sheet = package.Workbook.Worksheets.First();\n\n        ...\n\n        return new ActionOutput();\n    }\n}\n```\n\n切记：远离WPS，远离996..\n",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "EPPlus",
            "Excel",
            "WPS"
        ],
        "createdAt": "2019-08-21 11:00:12"
    },
    {
        "title": ".NET Core下操作Git，自动提交代码到 GitHub",
        "author": "阿星Plus",
        "url": "2019-08-21-netcore-worker-git",
        "markdown": ".NET Core 3.0 预览版发布已经好些时日了，博客园也已将其用于生产环境中，可见 .NET Core 日趋成熟\n\n回归正题，你想盖大楼吗？想 GitHub 首页一片绿吗？今天拿她玩玩自动提交代码至 GitHub。\n\n## 安装项目模板\n\n```shell\ndotnet new --install \"Microsoft.DotNet.Web.ProjectTemplates.3.0\"\ndotnet new worker\n```\n\n## 创建项目\n\n直接使用 .NET CLI 创建一个 Work Service 的项目\n\n```shell\ndotnet new worker -o AutomaticPush\n```\n\n用 Visual Studio 2019 打开项目可以看到以下代码\n\n```csharp\n// Program.cs\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.AddHostedService<Worker>();\n            });\n}\n```\n\n- 从 3.0 起 WebHost 被 Host 取代了\n- `CreateHostBuilder`创建 Host 并在`ConfigureServices`中调用`.AddHostedService<Worker>()`\n\n```csharp\n// Worker.cs\npublic class Worker : BackgroundService\n{\n    private readonly ILogger<Worker> _logger;\n    public Worker(ILogger<Worker> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            _logger.LogInformation(\"Worker running at: {time}\", DateTimeOffset.Now);\n            await Task.Delay(1000, stoppingToken);\n        }\n    }\n}\n```\n\nWorker 继承了 BackgroundService，在 override ExecuteAsync 方法中完成自动提交的代码\n\n.NET 下操作 Git 需要用到一个库 `LibGit2Sharp`，同时支持 .NET Framework 及 .NET Core\n\n在项目中安装使用\n\n```shell\nInstall-Package LibGit2Sharp\n```\n\n## LibGit2Sharp 简单使用\n\n- `Repository.Init(@\"D:\\Work\")` 在指定路径创建一个新的 Git 仓库，相当于 `git init`\n\n- `Repository.Clone(\"https://github.com/Meowv/Blog.git\", @\"D:\\Work\")` 拉取一个远程仓库到本地，相当于 `git clone`\n\n- `using (var repo = new Repository(@\"D:\\Blog\")){}` 打开本地存在的 Git 仓库\n\n- 获取 Branch\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      var branches = repo.Branches;\n\n      foreach (var item in branches)\n      {\n      }\n  }\n  ```\n\n- 获取 Commits\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      foreach (var commit in repo.Commits)\n      {\n      }\n  }\n  ```\n\n- 获取 Tags\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      foreach (var commit in repo.Tags)\n      {\n      }\n  }\n  ```\n\n- 更多操作请移步 https://github.com/libgit2/libgit2sharp\n\n## 自动 Push 代码盖大楼\n\n有了以上基础，就可以实现自动生成文件，push 代码到 GitHub 了。\n\n新建一个配置文件，存放我们 GitHub 仓库以及账号密码等重要信息\n\n```json\n{\n  \"repository\": \"本地git仓库绝对路径\",\n  \"username\": \"GitHub账号\",\n  \"password\": \"GitHub密码\",\n  \"name\": \"提交人\",\n  \"email\": \"邮箱\"\n}\n```\n\n在ExecuteAsync中读取配置文件信息\n\n```csharp\nvar configurationRoot = new ConfigurationBuilder().AddJsonFile(\"config.json\").Build();\n\nvar path = configurationRoot[\"repository\"];\nvar username = configurationRoot[\"username\"];\nvar password = configurationRoot[\"password\"];\nvar name = configurationRoot[\"name\"];\nvar email = configurationRoot[\"email\"];\n```\n\ngit会自动检测文件变化，所以就先自动按日期创建.log文件，不断生成内容然后提交\n\n```csharp\nwhile (!stoppingToken.IsCancellationRequested)\n{\n    var fileName = $\"{DateTime.Now.ToString(\"dd\")}.log\";\n    var content = DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\");\n\n    // 写入内容\n    WriteText(path, fileName, content);\n\n    using (var repo = new Repository(path))\n    {\n        // Stage the file\n        Commands.Stage(repo, \"*\");\n        // Create the committer's signature and commit\n        var author = new Signature(name, email, DateTime.Now);\n        var committer = author;\n        // Commit to the repository\n        var commit = repo.Commit(content, author, committer);\n        // git push\n        var options = new PushOptions\n        {\n            CredentialsProvider = new CredentialsHandler((url, usernameFromUrl, types) =>\n            {\n                return new UsernamePasswordCredentials()\n                {\n                    Username = username,\n                    Password = password\n                };\n            })\n        };\n        repo.Network.Push(repo.Branches[\"master\"], options);\n    }\n\n    Console.WriteLine(content);\n\n    // 等待60秒继续执行...\n    await Task.Delay(60000, stoppingToken);\n}\n\nprivate static void WriteText(string path, string fileName, string content)\n{\n    path = Path.Combine(path, DateTime.Now.ToString(@\"yyyy\\\\MM\"));\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    var filePath = Path.Combine(path, fileName);\n    using var fs = new FileStream(filePath, FileMode.Append);\n    using var sw = new StreamWriter(fs);\n    sw.WriteLine(content);\n}\n```\n\n至此，整个代码编写部分结束，项目发布后可以选择sc.exe注册为Windows服务，在这里推荐使用nssm(一个服务封装程序)，好了，赶紧盖大楼去吧~~\n",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "git",
            "GitHub",
            "LibGit2Sharp"
        ],
        "createdAt": "2019-08-21 15:40:41"
    },
    {
        "title": "两枚Visual Studio 2019密钥",
        "author": "阿星Plus",
        "url": "2019-08-22-vs2019-key",
        "markdown": "Visual Studio 2019 Enterprise：`BF8Y8-GN2QH-T84XB-QVY3B-RC4DF`\n\nVisual Studio 2019 Professional：`NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y`",
        "category": "Other",
        "tag": [
            "Visual Studio"
        ],
        "createdAt": "2019-08-22 14:32:12"
    },
    {
        "title": "使用MTA HTML5统计API来分析数据",
        "author": "阿星Plus",
        "url": "2019-08-23-mta-package",
        "markdown": "在开发个人博客的时候，用到了腾讯移动分析(MTA)，相比其他数据统计平台来说我喜欢她的简洁高效，易上手，同时文档也比较全面，提供了数据接口供用户调用。\n\n在看了MTA演示[Demo](https://mta.qq.com/mta/manage/ctr_demo)和[官方文档](https://mta.qq.com/docs/)后，我就决定使用 .NET Core将其HTML5统计API进行封装，以供博客直接调用，省去各种鉴权生成sign的操作。\n\n首先需要在[MTA](https://mta.qq.com/)官网进行HTML5应用创建，当然她还支持小程序和移动App。\n\n![MTA](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/mta.png)\n\n然后就可以看到如上图的应用管理界面，如果你不打算使用其API接口，直接拿到统计代码嵌入在自己网站中即可，不出意外10分钟左右即可查看网站部分指标的实时数据，次日可以查看昨日的全部数据。\n\n接下来继续，在调用MTA接口之前需要先生成sign，\n\n> 双方维护同一份私钥，在发起请求的时候，发起方(合作方)将当前的请求参数数组，按照key值进行排序，然后'key=value'拼接到加密串后，进行md5的编码。接收方以同样的处理方式，对ts小于或等于30分钟的请求进行处理，sign一致则合法，否则失败。\n\n有了这段算法描述，利用C#代码实现如下：\n\n```csharp\n/// <summary>\n/// 生成sign\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static string GgenerateSign(this Dictionary<string, string> keyValues)\n{\n    keyValues.Add(\"app_id\", MtaConfig.App_Id);\n    IDictionary<string, string> sortedParams = new SortedDictionary<string, string>(keyValues);\n    var iterator = sortedParams.GetEnumerator();\n    var sb = new StringBuilder();\n    while (iterator.MoveNext())\n    {\n        var key = iterator.Current.Key;\n        var value = iterator.Current.Value;\n        if (key.IsNotNullOrEmpty() && value.IsNotNullOrEmpty())\n        {\n            sb.Append(key).Append(\"=\").Append(value);\n        }\n    }\n    return (MtaConfig.SECRET_KEY + sb.ToString()).Md5();\n}\n```\n\n将参数放入一个字典，并按照key值进行排序。因为所有接口都需要参数`app_id`，所以将其默认添加进去，不在额外当做参数。\n\n`.Md5()`是一个扩展方法，将字符串按照MD5方式加密\n\n拿到sign后就可以调用接口了，因为是封装，那么将所有接口都保存为静态变量，代码如下\n\n```csharp\n#region 应用趋势\n\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_core_data = \"https://mta.qq.com/h5/api/ctr_core_data\";\n\n/// <summary>\n/// 应用实时小时数据\n/// 当天每小时的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_realtime = \"https://mta.qq.com/h5/api/ctr_realtime/get_by_hour\";\n\n/// <summary>\n/// 应用心跳数据\n/// 当前pv\\uv\\vv\\iv心跳数据数据\n/// </summary>\npublic static string Ctr_realtime_heartbeat = \"https://mta.qq.com/h5/api/ctr_realtime/heartbeat\";\n\n#endregion\n\n#region 访客分析\n\n/// <summary>\n/// 实时访客\n/// 在24小时内的实时访客信息\n/// </summary>\npublic static string Ctr_user_realtime = \"https://mta.qq.com/h5/api/ctr_user_realtime\";\n\n/// <summary>\n/// 新老访客比\n/// 按天查询当天新访客与旧访客的数量\n/// </summary>\npublic static string Ctr_user_compare = \"https://mta.qq.com/h5/api/ctr_user_compare\";\n\n/// <summary>\n/// 用户画像\n/// 查询用户画像数据，包含性别比例、年龄分布、学历分布、职业分布，数据为pv量\n/// </summary>\npublic static string Ctr_user_portrait = \"https://mta.qq.com/h5/api/ctr_user_portrait\";\n\n#endregion\n\n#region 客户端分析\n\n/// <summary>\n/// 地区数据\n/// 按天查询地区的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_area = \"https://mta.qq.com/h5/api/ctr_area/get_by_area\";\n\n/// <summary>\n/// 省市数据\n/// 按天查询省市下有流量的城市的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_area_province = \"https://mta.qq.com/h5/api/ctr_area/get_by_province\";\n\n/// <summary>\n/// 运营商\n/// 按天查询运营商的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_operator = \"https://mta.qq.com/h5/api/ctr_operator\";\n\n/// <summary>\n/// 终端属性列表\n/// 按天查询对应属性的终端信息数据\n/// </summary>\npublic static string Ctr_client_para = \"https://mta.qq.com/h5/api/ctr_client/get_by_para\";\n\n/// <summary>\n/// 终端信息\n/// 按天查询终端信息数据\n/// </summary>\npublic static string Ctr_client_content = \"https://mta.qq.com/h5/api/ctr_client/get_by_content\";\n\n#endregion\n\n#region 页面分析\n\n/// <summary>\n/// 页面排行-当天实时列表\n/// 查询当天所有url的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_page_realtime = \"https://mta.qq.com/h5/api/ctr_page/list_all_page_realtime\";\n\n/// <summary>\n/// 页面排行-离线列表\n/// 按天查询所有url的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_page_offline = \"https://mta.qq.com/h5/api/ctr_page/list_all_page_offline\";\n\n/// <summary>\n/// 页面排行-指定查询部分url\n/// 按天查询url的pv\\uv\\vv\\iv数据。\n/// </summary>\npublic static string Ctr_page_url = \"https://mta.qq.com/h5/api/ctr_page\";\n\n/// <summary>\n/// 性能监控\n/// 按天查询对应省市的访问延时与解析时长\n/// </summary>\npublic static string Ctr_page_speed = \"https://mta.qq.com/h5/api/ctr_page_speed\";\n\n/// <summary>\n/// 访问深度\n/// 按天查询用户访问深度\n/// </summary>\npublic static string Ctr_page_depth = \"https://mta.qq.com/h5/api/ctr_depth\";\n\n#endregion\n\n#region 来源分析\n\n/// <summary>\n/// 外部链接\n/// 按天查询外部同站链接带来的流量情情况\n/// </summary>\npublic static string Ctr_source_out = \"https://mta.qq.com/h5/api/ctr_source_out\";\n\n/// <summary>\n/// 入口页面\n/// 按天查询用户最后访问的进入次数与跳出率\n/// </summary>\npublic static string Ctr_page_land = \"https://mta.qq.com/h5/api/ctr_page_land\";\n\n/// <summary>\n/// 离开页面\n/// 按天查询最后访问页面的离次数\n/// </summary>\npublic static string Ctr_page_exit = \"https://mta.qq.com/h5/api/ctr_page_exit\";\n\n#endregion\n\n#region 自定义事件\n\n/// <summary>\n/// 自定义事件\n/// 按天查询自定义事件的pv\\uv\\vv\\iv\n/// </summary>\npublic static string Ctr_custom = \"https://mta.qq.com/h5/api/ctr_custom\";\n\n#endregion\n\n#region 渠道效果统计\n\n/// <summary>\n/// 渠道效果统计\n/// 按天查询渠道的分析数据\n/// </summary>\npublic static string Ctr_adtag = \"https://mta.qq.com/h5/api/ctr_adtag\";\n\n#endregion\n```\n\n接下来对照文档生成URL的查询参数，然后访问接口拿到返回数据\n\n```csharp\n/// <summary>\n/// 生成URL查询参数\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static string GgenerateQuery(this Dictionary<string, string> keyValues)\n{\n    var sign = keyValues.GgenerateSign();\n\n    var query = \"?\";\n\n    keyValues.ForEach(x =>\n    {\n        query += $\"{x.Key}={x.Value}&\";\n    });\n\n    return $\"{query}sign={sign}\";\n}\n```\n\n```csharp\n/// <summary>\n/// 获取MTA接口返回数据\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static async Task<string> GetMTAData(this Dictionary<string, string> keyValues, string api)\n{\n    var url = $\"{api}{keyValues.GgenerateQuery()}\";\n\n    // HWRequest()和HWRequestResult()是扩展方法，可以选择自己熟悉HTTP请求方法\n    var hwr = url.HWRequest();\n    string result = hwr.HWRequestResult();\n\n    return await Task.FromResult(result);\n}\n```\n\n到这里基本上就结束了，只需对照MTA文档传入对应的参数即可拿到返回的数据了。\n\n以其中一个接口为例，应用历史趋势，获取每天的pv、uv、vv、iv数据\n\n```csharp\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\n/// <param name=\"start_date\">开始时间（Y-m-d）</param>\n/// <param name=\"end_date\">结束时间（Y-m-d）</param>\n/// <param name=\"idx\">查询指标(pv,uv,vv,iv)，使用“,”间隔</param>\n/// <returns></returns>\npublic async Task<string> Ctr_core_data(string start_date, string end_date, string idx)\n{\n    var keyValues = new Dictionary<string, string>\n    {\n        { \"start_date\", start_date },\n        { \"end_date\", end_date },\n        { \"idx\", idx }\n    };\n    return await keyValues.GetMTAData(MtaConfig.Ctr_core_data);\n}\n```\n\n在controller中进行调用\n\n```csharp\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\n/// <param name=\"start_date\">开始时间（Y-m-d）</param>\n/// <param name=\"end_date\">结束时间（Y-m-d）</param>\n/// <param name=\"idx\">查询指标(pv,uv,vv,iv)，使用“,”间隔</param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"ctr_core_data\")]\npublic async Task<dynamic> Ctr_core_data(string start_date, string end_date, string idx)\n{\n    var result = await _mtaService.Ctr_core_data(start_date, end_date, idx);\n\n    return result.DeserializeFromJson<dynamic>();\n}\n```\n\n查询结果看下图\n\n![MTAAPI](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/mtaapi.png)\n\n详细代码可参考：https://github.com/Meowv/Blog/tree/master/src/MeowvBlog.MTA\n",
        "category": ".NET",
        "tag": [
            "MTA",
            "数据分析",
            "API"
        ],
        "createdAt": "2019-08-23 10:47:50"
    },
    {
        "title": "我已经看到了，撤回也没用了(PC微信防撤回补丁)",
        "author": "阿星Plus",
        "url": "2019-08-29-revoke-wechart-msg-patcher",
        "markdown": "前两天看 GitHub 发现一个有趣的项目，[PC微信防撤回补丁](https://github.com/huiyadanli/RevokeMsgPatcher)，本着研究学习的目的，在看过源码，一顿疯狂操作之后，了解了其原理是基于修改 wechatwin.dll 达到防撤回的。\n\n于是乎，自己动手玩一玩，以下为详细步骤：\n\n首先下载 [x64dbg](https://github.com/x64dbg/x64dbg)，我这里使用的是 x32dbg，效果是一样的。\n\n打开 x32dbg.exe，打开微信扫码登录，附加微信进程，此时微信处于假死状态，暂时不要使用。\n\n![wx1](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx1.gif)\n\n点击菜单栏下面 Symbols 按钮，搜索 \"WeChatWin\"，找到 WeChatWin.dll，双击进入\n\n![wx2](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx2.png)\n\n在当前界面右键，搜索，当前区域，字符串，输入 \"revokemsg\" 搜索，然后找到第一个字符串为 \"revokemsg\" 的命令双击进入跳转到二进制程序\n\n![wx3](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx3.png)\n![wx4](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx4.png)\n\n分析发现进入防撤回前有一个 je 跳转语句，满足撤回条件就进入到撤回流程，不满足就跳转到别的地方，直接将这里修改成无条件跳转到别的不撤回的地方，就实现了防撤回功能。进入 revokemsg 二进制界面后，找到它的前的一个命令，是一个 je 开头的命令，双击将其修改为 jmp。\n\n![wx5](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx5.gif)\n\n此时整个补丁已经修改完成，右键点击\"Patches\"，另存为新的 WeChatWin.dll，关掉 x32dbg 和微信，将新的 WeChatWin.dll 覆盖微信安装目录下即可。\n\n![wx6](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx6.gif)\n\n现在重新打开微信，扫码登陆，然后用手机给自己发几条消息然后撤回一下试试看，如果手机上消息显示撤回，电脑上消息还在，那就说明成功了。这么简单还不去试试？\n",
        "category": "Other",
        "tag": [
            "GitHub",
            "x64dbg",
            "x32dbg",
            "补丁",
            "微信"
        ],
        "createdAt": "2019-08-29 11:25:31"
    },
    {
        "title": "Win10 1903 运行安卓模拟器蓝屏解决方案",
        "author": "阿星Plus",
        "url": "2019-08-30-win10-bsod",
        "markdown": "由于没有安卓机，想要测试一些东西，所以选择了安卓模拟器，可是一运行模拟器就导致电脑蓝屏，试了 N 次都不行。\n\n于是在网上寻找解决方案，了解到导致蓝屏的原因都是因为虚拟化技术，我的系统是 Windows10 1903，加上之前开启了 Hyper-V 虚拟机，和 Windows 沙盒，再加上 Win10 对于安卓模拟器的虚拟化兼容不够才一直崩溃。\n\n解决方案：关闭 Hyper-V 和 Windows 沙盒，运行以下命令，重启电脑。\n\n```bash\nDISM /Online /Disable-Feature /FeatureName:\"Containers-DisposableClientVM\"\nDISM /Online /Disable-Feature /FeatureName:\"Microsoft-Hyper-V-All\"\nDISM /Online /Disable-Feature /FeatureName:\"VirtualMachinePlatform\"\n```\n",
        "category": "Other",
        "tag": [
            "Windows",
            "安卓模拟器",
            "蓝屏"
        ],
        "createdAt": "2019-08-30 09:45:28"
    },
    {
        "title": "←2017，2019→",
        "author": "阿星Plus",
        "url": "2019-11-27-2017_2019",
        "markdown": "时间过得真快啊，都还没来得及做好迎接2020的准备。\n\n距离2019年结束，只剩下一个多月了。\n\n2017年：当年我是瓜子脸，2019年：我长成了西瓜脸\n\n还有双下巴！\n\n两年之间多长了几十斤肉的自己，没有一顿饭是无辜的！\n\n头越来越秃，黑眼圈越来越重！\n\n三年时间，也收获颇多。\n\n时间，总会改变很多东西\n\n也总有一些东西历久弥新\n\n变化的是年轮，不变的是初心",
        "category": "Life",
        "tag": [
            "总结"
        ],
        "createdAt": "2019-11-27 15:22:23"
    },
    {
        "title": "2019 年终总结",
        "author": "阿星Plus",
        "url": "2020-01-02-2019-summary",
        "markdown": "哇，2020年了，大家都奔小康了吗？\n\n越长大感觉时间过得越快，都20年了我还沉浸在19年的各种欢乐中。\n\n到目前为止，加上实习经验，工作也有四个年头了。也算得上一个职场老手了，经历了各种代码的洗礼。然而却发现自己没有上学时的那种学习精神了，时常写代码到凌晨的我，经常感叹：学不动了。\n\n作为程序员，只有不断学习新的知识才能在工作中游刃有余不被淘汰。我是一名 .net 后端开发工程师，今年2月份离开上家公司，到了新的公司开始了新的编码生涯。我要感谢我的女朋友(未婚妻)对我的支持和鼓励，还有她随我居无定所辗转反侧的奔波。\n\n在新的公司写代码感觉比在上家公司写代码愉快了不少，毕竟是跳槽，总不能越跳越糟吧，哈哈。\n\n- 技术上紧跟微软步伐，所有新项目都采用 .net core开发，同时我也负责维护一个公司的老项目，是 .net framework 的一个和OCR识别相关的项目，生产着公司的所有数据。\n\n- 团队规模更加完善，前后端分离让专业的人干专业的事，我所在的小组，主要负责后端数据接口，协调整个公司的数据支撑，配合 .net core 技术写着各种API。\n\n- 领导和小组成员Nice，技术牛逼，容易接触，领导好说话，请假容易(不会出现19年的情况了)。\n\n- 工资上涨了，可能这是最主要的原因吧！\n\n记录一下，19年的大事年表：\n\n- 2月份，开工第一天裸辞，于2月底正式离职\n- 3月初，和女票前往云南旅游，happy了一周，同时完成了第一次坐飞机的技能点\n- 3月中旬，找工作投简历面试，成功入职一家教育科技公司。体验了一周6点起床，挤地铁两小时上班的生活，果断在新公司附近找房子住，然后就是和上家房东退租，各种来回跑搬家等琐事\n- 4-5月份，按部就班在新公司写代码，了解新业务\n- 6月份，公司高峰期，全月无休，完成职业生涯第一次通宵加班的技能点\n- 7-9月份，公司业务高峰期过后，闲暇时间系统学了Python，然后调休一周在家宅着休息，哪也没去，现在有点后悔，时间比较长，应该利用这段时间回家见双方家长的，还有就是领养了一只蓝猫，喵喵喵，我的最爱\n- 10月份，带女朋友回家见了父母，爸妈很喜欢，同时我也见了我未来的老丈人和丈母娘，哇，现在想想和做梦一样，哈哈哈。\n- 11-12月份，在完成公司编码任务的同时，自学前端技术React(React基础知识、Redux、React Router、React Hooks、Next.js等等)，到现在仍在继续学习中，真是有趣\n\n工作之余，学习各种新技术，用 .net core 完成了个人博客 [https://meowv.com](https://meowv.com) 的开发重构工作，已开源，地址：https://github.com/Meowv/Blog ，欢迎 star。\n\n今天是1月2号，我已经买了1月18回家的火车票，准备和父母一起前往女朋友家拜访，哈哈哈，这应该算是订婚吧，希望一切顺利。",
        "category": "Summary",
        "tag": [
            "年终总结",
            "总结",
            "2020"
        ],
        "createdAt": "2020-01-02 10:55:56"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目",
        "author": "阿星Plus",
        "url": "2020-05-15-blog",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext"
        ],
        "createdAt": "2020-05-15 15:33:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目",
        "author": "阿星Plus",
        "url": "2020-05-15-blog_01",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext"
        ],
        "createdAt": "2020-05-15 17:31:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来",
        "author": "阿星Plus",
        "url": "2020-05-17-blog_02",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext"
        ],
        "createdAt": "2020-05-17 13:13:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场",
        "author": "阿星Plus",
        "url": "2020-05-18-blog_03",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "Swagger"
        ],
        "createdAt": "2020-05-18 16:50:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先",
        "author": "阿星Plus",
        "url": "2020-05-19-blog_04",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abpv Next",
            "EntityFramework Core",
            "Code-First"
        ],
        "createdAt": "2020-05-19 14:18:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查",
        "author": "阿星Plus",
        "url": "2020-05-20-blog_05",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "EntityFramework Core",
            "Repository"
        ],
        "createdAt": "2020-05-20 13:14:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型",
        "author": "阿星Plus",
        "url": "2020-05-21-blog_06",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi",
            "Models"
        ],
        "createdAt": "2020-05-21 11:00:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁",
        "author": "阿星Plus",
        "url": "2020-05-22-blog_07",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "jwt"
        ],
        "createdAt": "2020-05-22 09:01:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录",
        "author": "阿星Plus",
        "url": "2020-05-25-blog_09",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "Filter",
            "Middleware",
            "Log4net"
        ],
        "createdAt": "2020-05-25 08:48:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API",
        "author": "阿星Plus",
        "url": "2020-05-23-blog_08",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "GitHub",
            "abp vNext",
            "Swagger",
            "jwt",
            "Authorize"
        ],
        "createdAt": "2020-05-23 10:04:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据",
        "author": "阿星Plus",
        "url": "2020-05-26-blog_10",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Redis",
            "abp vNext",
            "缓存"
        ],
        "createdAt": "2020-05-26 08:51:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理",
        "author": "阿星Plus",
        "url": "2020-05-27-blog_11",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "定时任务",
            "Hangfire"
        ],
        "createdAt": "2020-05-27 08:54:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射",
        "author": "阿星Plus",
        "url": "2020-05-28-blog_12",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "AutoMapper"
        ],
        "createdAt": "2020-05-28 08:49:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）",
        "author": "阿星Plus",
        "url": "2020-05-29-blog_13",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "xpath",
            "abp vNext",
            "定时任务"
        ],
        "createdAt": "2020-05-29 08:49:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）",
        "author": "阿星Plus",
        "url": "2020-05-30-blog_14",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "定时任务",
            "HtmlAgilityPack"
        ],
        "createdAt": "2020-05-30 11:12:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）",
        "author": "阿星Plus",
        "url": "2020-06-01-blog_15",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "定时任务",
            "PuppeteerSharp",
            "MailKit"
        ],
        "createdAt": "2020-06-01 09:02:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）",
        "author": "阿星Plus",
        "url": "2020-06-02-blog_16",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi"
        ],
        "createdAt": "2020-06-02 08:56:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）",
        "author": "阿星Plus",
        "url": "2020-06-03-blog_17",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Client\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi"
        ],
        "createdAt": "2020-06-03 08:23:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）",
        "author": "阿星Plus",
        "url": "2020-06-05-blog_18",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi"
        ],
        "createdAt": "2020-06-05 08:47:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）",
        "author": "阿星Plus",
        "url": "2020-06-06-blog_19",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi"
        ],
        "createdAt": "2020-06-06 09:21:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）",
        "author": "阿星Plus",
        "url": "2020-06-08-blog_20",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "abp vNext",
            "WebApi"
        ],
        "createdAt": "2020-06-08 08:57:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）",
        "author": "阿星Plus",
        "url": "2020-06-09-blog_21",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-09 09:09:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）",
        "author": "阿星Plus",
        "url": "2020-06-10-blog_22",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-10 08:58:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）",
        "author": "阿星Plus",
        "url": "2020-06-11-blog_23",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-11 08:54:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）",
        "author": "阿星Plus",
        "url": "2020-06-12-blog_24",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-12 08:57:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）",
        "author": "阿星Plus",
        "url": "2020-06-13-blog_25",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-13 09:11:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）",
        "author": "阿星Plus",
        "url": "2020-06-15-blog_26",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-15 09:07:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）",
        "author": "阿星Plus",
        "url": "2020-06-16-blog_27",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-16 08:54:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）",
        "author": "阿星Plus",
        "url": "2020-06-17-blog_28",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n终于到了这一步了，开发了 API，紧接着又开发了 Blazor 版的博客项目，庆祝本系列文章完结撒花。🎉🎉🎉\n\n既然开发完成了，还是拿出来溜溜比较好，本篇是本系列文章的最后一篇了，准备将 API 部署到 Linux，把前端 Blazor 开发的博客部署到 GitHub Pages。\n\n- **blog**：https://blazor.meowv.com/\n- **api**：https://api2.meowv.com/\n\n先放地址，体验一下，要有点耐心，第一次访问会下载资源文件到本地浏览器，后面访问就贼快了。\n\n也是第一次使用 Blazor 开发项目，不管怎么说，这个实验性的带教学和宣传目的博客总算是搞出来了，自己用的话，完全可以，同时在开发过程中自己也有不少收获。\n\n## 发布API\n\n发布自己写的后端API项目，必须要有属于自己的服务器，当然如果只是为了动动手玩玩就没啥必要了，因为 .NET Core 跨平台咱们可以任意选择，我这里演示将项目发布到 Linux 下。\n\n在这之前可以看一下我去年的一篇文章，[基于.NET Core开发的个人博客发布至CentOS小记](https://mp.weixin.qq.com/s/WtZlCvLWjolTX8NYVdlLoA) ，简单了解下。\n\n我的机器是很久之前撸羊毛的渣渣配置服务器，1G内存，1核CPU，1M带宽，不过对于我们这种小站来说没啥访问量，照样用。🤣🤣\n\n首先肯定是需要安装 .NET Core 运行环境，直接安装最新的 .NET Core 3.1 即可。这一步大家根据微软官方文档来就可以了，https://docs.microsoft.com/zh-cn/dotnet/core/install/linux 。\n\n安装完成后可以使用 `dotnet --list-runtimes` 查看运行时。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617215458097-1044857481.png)\n\n接着就可以去安装 Nginx ，高性能 Web 服务器，在这里使用它反向代理的功能，当然它的功能远不止于此。关于 Nginx 的安装我也不说了，如果你不懂，网上太多教程了。\n\n安装完成后可以使用 `nginx -V` 查看安装版本等信息。\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617220944495-1578220668.png)\n\n到这一步就可以把我们API项目部署上去了，直接利用 Visual Studio 将项目打包发布，`appsettings.json`配置文件信息填好，这一步不用多说吧，相信大家都会。\n\n![3](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222223476-457921761.png)\n\n利用 WinSCP 工具将发布好的代码上传至服务器，我这里新建了文件夹 qix/api2 方便自己管理，顺便提一句，WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。\n\n![4](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222814781-574516396.png)\n\n那么现在我们可以在终端中定位到API所在目录，`cd /qix/api2`，然后执行命令启动项目`dotnet run Meowv.Blog.HttpApi.Hosting.dll`这时候便会看到输出信息，我们就可以使用服务器IP+端口的方式访问到API了。\n\n如果只是这样肯定不是我想要的，这时候就引入了 Linux 下的守护进程，就类似于 Windows 下面的服务一样，让守护进程帮助我们运行项目，当关机、重启或者其它异常问题出现时，可以自动帮我们重启应用，就是自动执行`dotnet run xxx.dll`这句命令。\n\n关于守护进程用的比较多的，supervisor 与 pm2 ，前者基于Python开发的，后者是基于nodejs开发的。\n\n咱这里就选用 supervisor 了，当然 pm2 也不错也可以用用。\n\n在 centos 下安装 supervisor 也很简单，直接贴几行代码，照着执行即可。\n\n```ini\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n安装成功后还需要花点时间去配置它，找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释，可以改成向下面这样。\n\n```ini\n...\n[include]\nfiles = conf.d/*.ini\n```\n\n这时候就可以监听到 conf.d 文件夹下面的 ini 配置文件了，在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建一个配置文件 api2_meowv.conf 文件，名字随便起，内容如下：\n\n```ini\n[program:api2_meowv] # api2_meowv程序名称\ncommand=dotnet Meowv.Blog.HttpApi.Hosting.dll # 执行的命令\ndirectory=/qix/api2  # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production # 环境变量\nuser=root\nstopsignal=INT \nautostart=true # 是否自启动\nautorestart=true # 是否自动重启\nstartsecs=3 # 自动重启时间间隔（s）\nstderr_logfile=/var/log/api2.meowv.com.err.log #错误日志文件指向目录\nstdout_logfile=/var/log/api2.meowv.com.out.log #输出日志文件指向目录\n```\n\n每行都带有注释，很清楚知道是干啥用的，顺便贴几条常用的命令：\n\n```ini\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n\n![5](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617225533767-1029923751.png)\n\n使用上面命令成功启动项目，使用IP+端口的方式去访问API肯定是不友好的，这时候就需要一个域名了，我这里将新建一个二级域名 api2.meowv.com 执行新开发的API项目。\n\n关于域名的解析啥的不说了，配置完域名我顺便去申请了一个SSL证书，使用HTTPS的方式访问。\n\n这时可以去配置 Nginx 方向代理了。来到 nginx 安装目录，我这里是 /etc/nginx ，新建一个文件夹 ssl ，将申请的SSL证书放进去，然后再 conf.d 文件夹下新建一个 api2_meowv.conf 文件，写入下面的配置信息。\n\n```nginx\nserver {\n        listen 443 ssl;\n        server_name api2.meowv.com;\n        ssl_certificate ssl/1_api2.meowv.com_bundle.crt; \n        ssl_certificate_key ssl/2_api2.meowv.com.key; \n        ssl_session_timeout 5m;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n\tssl_prefer_server_ciphers on;\n        location / {\n             if ($request_method = 'OPTIONS') {\n\t\tadd_header Access-Control-Allow-Headers 'Authorization,Content-Type';\n             \tadd_header Access-Control-Allow-Origin *;\n             \tadd_header Access-Control-Allow-Credentials true; \n             \tadd_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n             \treturn 204;\n             }\n             proxy_pass http://localhost:5009;\n             proxy_set_header   X-Real-IP        $remote_addr;\n             proxy_set_header   Host             $host;\n             proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n\t     client_max_body_size 20M;\n        }\n}\n\nserver {\n\tlisten 80;\n\tserver_name api2.meowv.com;\n\trewrite ^(.*)$ https://api2.meowv.com;\n}\n```\n\n![6](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617232140637-752750064.png)\n\n\n关于配置信息大家可以自己去学习一下，我这里也是简单的使用，我这里监听的端口是 5009，这个端口在 API 项目中是可以自定义的，相信大家都知道。做好以上操作后，在终端执行 `nginx -s reloa`，刷新 nginx 配置使其生效，然后就大功告成了。\n\n关于项目中的数据库和Redis缓存，大家可以自行安装。数据库可以选择使用Sqlite，项目中已经做了一键切换数据库。安装Redis也很简单，相信大家可以自己完成，Redis可用可不用，可以直接关闭。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617231936439-1402332824.png)\n\n现在API项目便发布成功，将其部署在Linux系统下面，有了线上正常运行的API，接下来把前端 Blazor 开发的博客也发一下。\n\n## 发布Blog\n\n为了节省服务器资源，现在里面已经容纳了超级多的东西了，我准备将 Blog 部署在 GitHub Pages 上。\n\n使用 Blazor WebAssembly 发布后是纯静态的文件，所以啊，其实放在哪里都可以。无关乎环境，只要可以开启一个WEB服务即可。\n\n在GitHub上创建一个仓库来放我们的发布后的代码，关于创建仓库不会的看这里，https://pages.github.com 。\n\n接下来去发布 Blazor 项目，发布之前改一下API地址，当然这个也可以做成配置文件形式的。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618201703995-687896253.png)\n\n![8](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618202057528-110490665.png)\n\n然后将创建好的仓库克隆下来，把博客静态文件拷贝进去，这时候还不能直接push到仓库中，为了适配 GitHub Pages 我们还要做几点改动。\n\nGitHub Pages 使用的是 Jekyll，以特殊字符开头的文件夹是不会被映射到路由中去的，我们发布的静态文件中刚好有以`_`开头的文件夹`_framework`，为了解决这个问题可以在仓库下面创建一个以`.nojekyll`命名的空文件即可。\n\n根据实际操作和踩坑，现在如果发布还是会报一个无法加载资源的错误`The resource has been blocked.`，然后在GitHub找到了解决办法，详见：https://github.com/dotnet/aspnetcore/issues/19907#issuecomment-600054113 。\n\n新建一个`.gitattributes`文件，写入内容：`* binary`，即可，现在将文件 push 到仓库。\n\n然后在仓库的settings下面开启 GitHub Pages 功能选项。\n\n![9](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203548822-1059079953.png)\n\n我这里自定义了一个域名，如果你也想自定义域名可以在根目录添加一个名为`CNAME`的文件，里面的内容就是你的域名，我这里就是：blazor.meowv.com 。\n\n![10](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203930658-681131577.png)\n\n最后在去配置一下域名的 CNAME 解析即可，等待 DNS 生效，便可以用自定义域名访问了。\n\n## 结束语\n\n本系列文章从零开始搭建了API，使用 Blazor 开发了一个简单的博客系统，功能不是很多。整体来说从无到有，自己也踩了一遍坑，也算有不少收获了。\n\n在这里再次感谢那些在公众号给我赞赏的人。🌹🌹🌹\n\n可能整体涉及到的东西不是很多，广度和深度都没有，只是很基础的用了用，在写之前我也已经说过，这些系列是用来记录自己的编码过程，因为大佬们都不愿意出来分享，所以我们渣渣只能做到这种程度。\n\n如果对你没啥帮助，权当看过笑过😀😀或者右上角点一下小叉叉❌❌，因为不管你做的如何，总有人喜欢说三道四~~\n\n如果对你有些许帮助，请多多推广哟。✨✨✨\n\n最后大家可以关注一下我的微信公众号：『**[阿星Plus](https://files-cdn.cnblogs.com/files/meowv/wx.bmp)**』🤞🤞🤞\n\n因为疫情影响，今年高考推迟到7月份，每年高考便是我所在公司的业务高峰期，接下来实在太忙，估计也没时间创作了，正好准备休息一段时间，好好思考思考后面为大家带来更好的文章，有缘人下个系列见吧。😊😊😊",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-17 08:54:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）",
        "author": "阿星Plus",
        "url": "2020-06-18-blog_29",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n终于到了这一步了，开发了 API，紧接着又开发了 Blazor 版的博客项目，庆祝本系列文章完结撒花。🎉🎉🎉\n\n既然开发完成了，还是拿出来溜溜比较好，本篇是本系列文章的最后一篇了，准备将 API 部署到 Linux，把前端 Blazor 开发的博客部署到 GitHub Pages。\n\n- **blog**：https://blazor.meowv.com/\n- **api**：https://api2.meowv.com/\n\n先放地址，体验一下，要有点耐心，第一次访问会下载资源文件到本地浏览器，后面访问就贼快了。\n\n也是第一次使用 Blazor 开发项目，不管怎么说，这个实验性的带教学和宣传目的博客总算是搞出来了，自己用的话，完全可以，同时在开发过程中自己也有不少收获。\n\n## 发布API\n\n发布自己写的后端API项目，必须要有属于自己的服务器，当然如果只是为了动动手玩玩就没啥必要了，因为 .NET Core 跨平台咱们可以任意选择，我这里演示将项目发布到 Linux 下。\n\n在这之前可以看一下我去年的一篇文章，[基于.NET Core开发的个人博客发布至CentOS小记](https://mp.weixin.qq.com/s/WtZlCvLWjolTX8NYVdlLoA) ，简单了解下。\n\n我的机器是很久之前撸羊毛的渣渣配置服务器，1G内存，1核CPU，1M带宽，不过对于我们这种小站来说没啥访问量，照样用。🤣🤣\n\n首先肯定是需要安装 .NET Core 运行环境，直接安装最新的 .NET Core 3.1 即可。这一步大家根据微软官方文档来就可以了，https://docs.microsoft.com/zh-cn/dotnet/core/install/linux 。\n\n安装完成后可以使用 `dotnet --list-runtimes` 查看运行时。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617215458097-1044857481.png)\n\n接着就可以去安装 Nginx ，高性能 Web 服务器，在这里使用它反向代理的功能，当然它的功能远不止于此。关于 Nginx 的安装我也不说了，如果你不懂，网上太多教程了。\n\n安装完成后可以使用 `nginx -V` 查看安装版本等信息。\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617220944495-1578220668.png)\n\n到这一步就可以把我们API项目部署上去了，直接利用 Visual Studio 将项目打包发布，`appsettings.json`配置文件信息填好，这一步不用多说吧，相信大家都会。\n\n![3](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222223476-457921761.png)\n\n利用 WinSCP 工具将发布好的代码上传至服务器，我这里新建了文件夹 qix/api2 方便自己管理，顺便提一句，WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。\n\n![4](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222814781-574516396.png)\n\n那么现在我们可以在终端中定位到API所在目录，`cd /qix/api2`，然后执行命令启动项目`dotnet run Meowv.Blog.HttpApi.Hosting.dll`这时候便会看到输出信息，我们就可以使用服务器IP+端口的方式访问到API了。\n\n如果只是这样肯定不是我想要的，这时候就引入了 Linux 下的守护进程，就类似于 Windows 下面的服务一样，让守护进程帮助我们运行项目，当关机、重启或者其它异常问题出现时，可以自动帮我们重启应用，就是自动执行`dotnet run xxx.dll`这句命令。\n\n关于守护进程用的比较多的，supervisor 与 pm2 ，前者基于Python开发的，后者是基于nodejs开发的。\n\n咱这里就选用 supervisor 了，当然 pm2 也不错也可以用用。\n\n在 centos 下安装 supervisor 也很简单，直接贴几行代码，照着执行即可。\n\n```ini\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n安装成功后还需要花点时间去配置它，找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释，可以改成向下面这样。\n\n```ini\n...\n[include]\nfiles = conf.d/*.ini\n```\n\n这时候就可以监听到 conf.d 文件夹下面的 ini 配置文件了，在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建一个配置文件 api2_meowv.conf 文件，名字随便起，内容如下：\n\n```ini\n[program:api2_meowv] # api2_meowv程序名称\ncommand=dotnet Meowv.Blog.HttpApi.Hosting.dll # 执行的命令\ndirectory=/qix/api2  # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production # 环境变量\nuser=root\nstopsignal=INT \nautostart=true # 是否自启动\nautorestart=true # 是否自动重启\nstartsecs=3 # 自动重启时间间隔（s）\nstderr_logfile=/var/log/api2.meowv.com.err.log #错误日志文件指向目录\nstdout_logfile=/var/log/api2.meowv.com.out.log #输出日志文件指向目录\n```\n\n每行都带有注释，很清楚知道是干啥用的，顺便贴几条常用的命令：\n\n```ini\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n\n![5](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617225533767-1029923751.png)\n\n使用上面命令成功启动项目，使用IP+端口的方式去访问API肯定是不友好的，这时候就需要一个域名了，我这里将新建一个二级域名 api2.meowv.com 执行新开发的API项目。\n\n关于域名的解析啥的不说了，配置完域名我顺便去申请了一个SSL证书，使用HTTPS的方式访问。\n\n这时可以去配置 Nginx 方向代理了。来到 nginx 安装目录，我这里是 /etc/nginx ，新建一个文件夹 ssl ，将申请的SSL证书放进去，然后再 conf.d 文件夹下新建一个 api2_meowv.conf 文件，写入下面的配置信息。\n\n```nginx\nserver {\n        listen 443 ssl;\n        server_name api2.meowv.com;\n        ssl_certificate ssl/1_api2.meowv.com_bundle.crt; \n        ssl_certificate_key ssl/2_api2.meowv.com.key; \n        ssl_session_timeout 5m;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n\tssl_prefer_server_ciphers on;\n        location / {\n             if ($request_method = 'OPTIONS') {\n\t\tadd_header Access-Control-Allow-Headers 'Authorization,Content-Type';\n             \tadd_header Access-Control-Allow-Origin *;\n             \tadd_header Access-Control-Allow-Credentials true; \n             \tadd_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n             \treturn 204;\n             }\n             proxy_pass http://localhost:5009;\n             proxy_set_header   X-Real-IP        $remote_addr;\n             proxy_set_header   Host             $host;\n             proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n\t     client_max_body_size 20M;\n        }\n}\n\nserver {\n\tlisten 80;\n\tserver_name api2.meowv.com;\n\trewrite ^(.*)$ https://api2.meowv.com;\n}\n```\n\n![6](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617232140637-752750064.png)\n\n\n关于配置信息大家可以自己去学习一下，我这里也是简单的使用，我这里监听的端口是 5009，这个端口在 API 项目中是可以自定义的，相信大家都知道。做好以上操作后，在终端执行 `nginx -s reloa`，刷新 nginx 配置使其生效，然后就大功告成了。\n\n关于项目中的数据库和Redis缓存，大家可以自行安装。数据库可以选择使用Sqlite，项目中已经做了一键切换数据库。安装Redis也很简单，相信大家可以自己完成，Redis可用可不用，可以直接关闭。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617231936439-1402332824.png)\n\n现在API项目便发布成功，将其部署在Linux系统下面，有了线上正常运行的API，接下来把前端 Blazor 开发的博客也发一下。\n\n## 发布Blog\n\n为了节省服务器资源，现在里面已经容纳了超级多的东西了，我准备将 Blog 部署在 GitHub Pages 上。\n\n使用 Blazor WebAssembly 发布后是纯静态的文件，所以啊，其实放在哪里都可以。无关乎环境，只要可以开启一个WEB服务即可。\n\n在GitHub上创建一个仓库来放我们的发布后的代码，关于创建仓库不会的看这里，https://pages.github.com 。\n\n接下来去发布 Blazor 项目，发布之前改一下API地址，当然这个也可以做成配置文件形式的。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618201703995-687896253.png)\n\n![8](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618202057528-110490665.png)\n\n然后将创建好的仓库克隆下来，把博客静态文件拷贝进去，这时候还不能直接push到仓库中，为了适配 GitHub Pages 我们还要做几点改动。\n\nGitHub Pages 使用的是 Jekyll，以特殊字符开头的文件夹是不会被映射到路由中去的，我们发布的静态文件中刚好有以`_`开头的文件夹`_framework`，为了解决这个问题可以在仓库下面创建一个以`.nojekyll`命名的空文件即可。\n\n根据实际操作和踩坑，现在如果发布还是会报一个无法加载资源的错误`The resource has been blocked.`，然后在GitHub找到了解决办法，详见：https://github.com/dotnet/aspnetcore/issues/19907#issuecomment-600054113 。\n\n新建一个`.gitattributes`文件，写入内容：`* binary`，即可，现在将文件 push 到仓库。\n\n然后在仓库的settings下面开启 GitHub Pages 功能选项。\n\n![9](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203548822-1059079953.png)\n\n我这里自定义了一个域名，如果你也想自定义域名可以在根目录添加一个名为`CNAME`的文件，里面的内容就是你的域名，我这里就是：blazor.meowv.com 。\n\n![10](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203930658-681131577.png)\n\n最后在去配置一下域名的 CNAME 解析即可，等待 DNS 生效，便可以用自定义域名访问了。\n\n## 结束语\n\n本系列文章从零开始搭建了API，使用 Blazor 开发了一个简单的博客系统，功能不是很多。整体来说从无到有，自己也踩了一遍坑，也算有不少收获了。\n\n在这里再次感谢那些在公众号给我赞赏的人。🌹🌹🌹\n\n可能整体涉及到的东西不是很多，广度和深度都没有，只是很基础的用了用，在写之前我也已经说过，这些系列是用来记录自己的编码过程，因为大佬们都不愿意出来分享，所以我们渣渣只能做到这种程度。\n\n如果对你没啥帮助，权当看过笑过😀😀或者右上角点一下小叉叉❌❌，因为不管你做的如何，总有人喜欢说三道四~~\n\n如果对你有些许帮助，请多多推广哟。✨✨✨\n\n最后大家可以关注一下我的微信公众号：『**[阿星Plus](https://files-cdn.cnblogs.com/files/meowv/wx.bmp)**』🤞🤞🤞\n\n因为疫情影响，今年高考推迟到7月份，每年高考便是我所在公司的业务高峰期，接下来实在太忙，估计也没时间创作了，正好准备休息一段时间，好好思考思考后面为大家带来更好的文章，有缘人下个系列见吧。😊😊😊",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-18 08:57:00"
    },
    {
        "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目",
        "author": "阿星Plus",
        "url": "2020-06-19-blog_30",
        "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n终于到了这一步了，开发了 API，紧接着又开发了 Blazor 版的博客项目，庆祝本系列文章完结撒花。🎉🎉🎉\n\n既然开发完成了，还是拿出来溜溜比较好，本篇是本系列文章的最后一篇了，准备将 API 部署到 Linux，把前端 Blazor 开发的博客部署到 GitHub Pages。\n\n- **blog**：https://blazor.meowv.com/\n- **api**：https://api2.meowv.com/\n\n先放地址，体验一下，要有点耐心，第一次访问会下载资源文件到本地浏览器，后面访问就贼快了。\n\n也是第一次使用 Blazor 开发项目，不管怎么说，这个实验性的带教学和宣传目的博客总算是搞出来了，自己用的话，完全可以，同时在开发过程中自己也有不少收获。\n\n## 发布API\n\n发布自己写的后端API项目，必须要有属于自己的服务器，当然如果只是为了动动手玩玩就没啥必要了，因为 .NET Core 跨平台咱们可以任意选择，我这里演示将项目发布到 Linux 下。\n\n在这之前可以看一下我去年的一篇文章，[基于.NET Core开发的个人博客发布至CentOS小记](https://mp.weixin.qq.com/s/WtZlCvLWjolTX8NYVdlLoA) ，简单了解下。\n\n我的机器是很久之前撸羊毛的渣渣配置服务器，1G内存，1核CPU，1M带宽，不过对于我们这种小站来说没啥访问量，照样用。🤣🤣\n\n首先肯定是需要安装 .NET Core 运行环境，直接安装最新的 .NET Core 3.1 即可。这一步大家根据微软官方文档来就可以了，https://docs.microsoft.com/zh-cn/dotnet/core/install/linux 。\n\n安装完成后可以使用 `dotnet --list-runtimes` 查看运行时。\n\n![1](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617215458097-1044857481.png)\n\n接着就可以去安装 Nginx ，高性能 Web 服务器，在这里使用它反向代理的功能，当然它的功能远不止于此。关于 Nginx 的安装我也不说了，如果你不懂，网上太多教程了。\n\n安装完成后可以使用 `nginx -V` 查看安装版本等信息。\n\n![2](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617220944495-1578220668.png)\n\n到这一步就可以把我们API项目部署上去了，直接利用 Visual Studio 将项目打包发布，`appsettings.json`配置文件信息填好，这一步不用多说吧，相信大家都会。\n\n![3](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222223476-457921761.png)\n\n利用 WinSCP 工具将发布好的代码上传至服务器，我这里新建了文件夹 qix/api2 方便自己管理，顺便提一句，WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。\n\n![4](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222814781-574516396.png)\n\n那么现在我们可以在终端中定位到API所在目录，`cd /qix/api2`，然后执行命令启动项目`dotnet run Meowv.Blog.HttpApi.Hosting.dll`这时候便会看到输出信息，我们就可以使用服务器IP+端口的方式访问到API了。\n\n如果只是这样肯定不是我想要的，这时候就引入了 Linux 下的守护进程，就类似于 Windows 下面的服务一样，让守护进程帮助我们运行项目，当关机、重启或者其它异常问题出现时，可以自动帮我们重启应用，就是自动执行`dotnet run xxx.dll`这句命令。\n\n关于守护进程用的比较多的，supervisor 与 pm2 ，前者基于Python开发的，后者是基于nodejs开发的。\n\n咱这里就选用 supervisor 了，当然 pm2 也不错也可以用用。\n\n在 centos 下安装 supervisor 也很简单，直接贴几行代码，照着执行即可。\n\n```ini\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n安装成功后还需要花点时间去配置它，找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释，可以改成向下面这样。\n\n```ini\n...\n[include]\nfiles = conf.d/*.ini\n```\n\n这时候就可以监听到 conf.d 文件夹下面的 ini 配置文件了，在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建一个配置文件 api2_meowv.conf 文件，名字随便起，内容如下：\n\n```ini\n[program:api2_meowv] # api2_meowv程序名称\ncommand=dotnet Meowv.Blog.HttpApi.Hosting.dll # 执行的命令\ndirectory=/qix/api2  # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production # 环境变量\nuser=root\nstopsignal=INT \nautostart=true # 是否自启动\nautorestart=true # 是否自动重启\nstartsecs=3 # 自动重启时间间隔（s）\nstderr_logfile=/var/log/api2.meowv.com.err.log #错误日志文件指向目录\nstdout_logfile=/var/log/api2.meowv.com.out.log #输出日志文件指向目录\n```\n\n每行都带有注释，很清楚知道是干啥用的，顺便贴几条常用的命令：\n\n```ini\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n\n![5](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617225533767-1029923751.png)\n\n使用上面命令成功启动项目，使用IP+端口的方式去访问API肯定是不友好的，这时候就需要一个域名了，我这里将新建一个二级域名 api2.meowv.com 执行新开发的API项目。\n\n关于域名的解析啥的不说了，配置完域名我顺便去申请了一个SSL证书，使用HTTPS的方式访问。\n\n这时可以去配置 Nginx 方向代理了。来到 nginx 安装目录，我这里是 /etc/nginx ，新建一个文件夹 ssl ，将申请的SSL证书放进去，然后再 conf.d 文件夹下新建一个 api2_meowv.conf 文件，写入下面的配置信息。\n\n```nginx\nserver {\n        listen 443 ssl;\n        server_name api2.meowv.com;\n        ssl_certificate ssl/1_api2.meowv.com_bundle.crt; \n        ssl_certificate_key ssl/2_api2.meowv.com.key; \n        ssl_session_timeout 5m;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n\tssl_prefer_server_ciphers on;\n        location / {\n             if ($request_method = 'OPTIONS') {\n\t\tadd_header Access-Control-Allow-Headers 'Authorization,Content-Type';\n             \tadd_header Access-Control-Allow-Origin *;\n             \tadd_header Access-Control-Allow-Credentials true; \n             \tadd_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n             \treturn 204;\n             }\n             proxy_pass http://localhost:5009;\n             proxy_set_header   X-Real-IP        $remote_addr;\n             proxy_set_header   Host             $host;\n             proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n\t     client_max_body_size 20M;\n        }\n}\n\nserver {\n\tlisten 80;\n\tserver_name api2.meowv.com;\n\trewrite ^(.*)$ https://api2.meowv.com;\n}\n```\n\n![6](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617232140637-752750064.png)\n\n\n关于配置信息大家可以自己去学习一下，我这里也是简单的使用，我这里监听的端口是 5009，这个端口在 API 项目中是可以自定义的，相信大家都知道。做好以上操作后，在终端执行 `nginx -s reloa`，刷新 nginx 配置使其生效，然后就大功告成了。\n\n关于项目中的数据库和Redis缓存，大家可以自行安装。数据库可以选择使用Sqlite，项目中已经做了一键切换数据库。安装Redis也很简单，相信大家可以自己完成，Redis可用可不用，可以直接关闭。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200617231936439-1402332824.png)\n\n现在API项目便发布成功，将其部署在Linux系统下面，有了线上正常运行的API，接下来把前端 Blazor 开发的博客也发一下。\n\n## 发布Blog\n\n为了节省服务器资源，现在里面已经容纳了超级多的东西了，我准备将 Blog 部署在 GitHub Pages 上。\n\n使用 Blazor WebAssembly 发布后是纯静态的文件，所以啊，其实放在哪里都可以。无关乎环境，只要可以开启一个WEB服务即可。\n\n在GitHub上创建一个仓库来放我们的发布后的代码，关于创建仓库不会的看这里，https://pages.github.com 。\n\n接下来去发布 Blazor 项目，发布之前改一下API地址，当然这个也可以做成配置文件形式的。\n\n![7](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618201703995-687896253.png)\n\n![8](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618202057528-110490665.png)\n\n然后将创建好的仓库克隆下来，把博客静态文件拷贝进去，这时候还不能直接push到仓库中，为了适配 GitHub Pages 我们还要做几点改动。\n\nGitHub Pages 使用的是 Jekyll，以特殊字符开头的文件夹是不会被映射到路由中去的，我们发布的静态文件中刚好有以`_`开头的文件夹`_framework`，为了解决这个问题可以在仓库下面创建一个以`.nojekyll`命名的空文件即可。\n\n根据实际操作和踩坑，现在如果发布还是会报一个无法加载资源的错误`The resource has been blocked.`，然后在GitHub找到了解决办法，详见：https://github.com/dotnet/aspnetcore/issues/19907#issuecomment-600054113 。\n\n新建一个`.gitattributes`文件，写入内容：`* binary`，即可，现在将文件 push 到仓库。\n\n然后在仓库的settings下面开启 GitHub Pages 功能选项。\n\n![9](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203548822-1059079953.png)\n\n我这里自定义了一个域名，如果你也想自定义域名可以在根目录添加一个名为`CNAME`的文件，里面的内容就是你的域名，我这里就是：blazor.meowv.com 。\n\n![10](https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203930658-681131577.png)\n\n最后在去配置一下域名的 CNAME 解析即可，等待 DNS 生效，便可以用自定义域名访问了。\n\n## 结束语\n\n本系列文章从零开始搭建了API，使用 Blazor 开发了一个简单的博客系统，功能不是很多。整体来说从无到有，自己也踩了一遍坑，也算有不少收获了。\n\n在这里再次感谢那些在公众号给我赞赏的人。🌹🌹🌹\n\n可能整体涉及到的东西不是很多，广度和深度都没有，只是很基础的用了用，在写之前我也已经说过，这些系列是用来记录自己的编码过程，因为大佬们都不愿意出来分享，所以我们渣渣只能做到这种程度。\n\n如果对你没啥帮助，权当看过笑过😀😀或者右上角点一下小叉叉❌❌，因为不管你做的如何，总有人喜欢说三道四~~\n\n如果对你有些许帮助，请多多推广哟。✨✨✨\n\n最后大家可以关注一下我的微信公众号：『**[阿星Plus](https://files-cdn.cnblogs.com/files/meowv/wx.bmp)**』🤞🤞🤞\n\n因为疫情影响，今年高考推迟到7月份，每年高考便是我所在公司的业务高峰期，接下来实在太忙，估计也没时间创作了，正好准备休息一段时间，好好思考思考后面为大家带来更好的文章，有缘人下个系列见吧。😊😊😊",
        "category": ".NET",
        "tag": [
            ".NET Core",
            "Blazor"
        ],
        "createdAt": "2020-06-19 08:55:00"
    },
    {
        "title": "git commit emoji 使用指南",
        "author": "阿星Plus",
        "url": "2020-07-20-git-commit-emoji",
        "markdown": "emoji                                   | emoji 代码                   | commit 说明\n:--------                               | :--------                    | :--------\n:tada: (庆祝)                           | `:tada:`                     | 初次提交\n:new: (全新)                            | `:new:`                      | 引入新功能\n:bookmark: (书签)                       | `:bookmark:`                 | 发行/版本标签\n:bug: (bug)                             | `:bug:`                      | 修复 bug\n:ambulance: (急救车)                    | `:ambulance:`                | 重要补丁\n:globe_with_meridians: (地球)           | `:globe_with_meridians:`     | 国际化与本地化\n:lipstick: (口红)                       | `:lipstick:`                 | 更新 UI 和样式文件\n:clapper: (场记板)                      | `:clapper:`                  | 更新演示/示例\n:rotating_light: (警车灯)               | `:rotating_light:`           | 移除 linter 警告\n:wrench: (扳手)                         | `:wrench:`                   | 修改配置文件\n:heavy_plus_sign: (加号)                | `:heavy_plus_sign:`          | 增加一个依赖\n:heavy_minus_sign: (减号)               | `:heavy_minus_sign:`         | 减少一个依赖\n:arrow_up: (上升箭头)                   | `:arrow_up:`                 | 升级依赖\n:arrow_down: (下降箭头)                 | `:arrow_down:`               | 降级依赖\n:zap: (闪电)<br>:racehorse: (赛马)      | `:zap:`<br>`:racehorse:`      | 提升性能\n:chart_with_upwards_trend: (上升趋势图) | `:chart_with_upwards_trend:` | 添加分析或跟踪代码\n:rocket: (火箭)                         | `:rocket:`                   | 部署功能\n:white_check_mark: (白色复选框)         | `:white_check_mark:`           | 增加测试\n:memo: (备忘录)<br>:book: (书)          | `:memo:`<br>`:book:`          | 撰写文档\n:hammer: (锤子)                         | `:hammer:`                   | 重大重构\n:art: (调色板)                          | `:art:`                      | 改进代码结构/代码格式\n:fire: (火焰)                           | `:fire:`                     | 移除代码或文件\n:pencil2: (铅笔)                        | `:pencil2:`                  | 修复 typo\n:construction: (施工)                   | `:construction:`             | 工作进行中\n:wastebasket: (垃圾桶)                  | `:wastebasket:`              | 废弃或删除\n:wheelchair: (轮椅)                     | `:wheelchair:`               | 可访问性\n:construction_worker: (工人)            | `:construction_worker:`      | 添加 CI 构建系统\n:green_heart: (绿心)                    | `:green_heart:`              | 修复 CI 构建问题\n:lock: (锁)                             | `:lock:`                     | 修复安全问题\n:whale: (鲸鱼)                          | `:whale:`                    | Docker 相关工作\n:apple: (苹果)                          | `:apple:`                    | 修复 macOS 下的问题\n:penguin: (企鹅)                        | `:penguin:`                  | 修复 Linux 下的问题\n:checkered_flag: (旗帜)                 | `:checkered_flag:`           | 修复 Windows 下的问题\n:twisted_rightwards_arrows: (交叉箭头)   | `:twisted_rightwards_arrows:`| 分支合并",
        "category": "Other",
        "tag": [
            "git",
            "Emiji"
        ],
        "createdAt": "2020-07-20 10:27:48"
    }
]